{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AgriGEE.lite","text":""},{"location":"#overview","title":"Overview","text":"<p>AgriGEE.lite is a high-performance Google Earth Engine (GEE) wrapper designed to simplify and accelerate the download of Analysis Ready Multimodal Data (ARD) for agricultural and vegetation monitoring. The library focuses on making satellite data as accessible as reading a CSV file with pandas, removing the complexity typically associated with Earth Engine programming.</p>"},{"location":"#what-makes-agrigeelite-special","title":"What makes AgriGEE.lite special?","text":"<ul> <li>Simplified API: Download satellite time series with just a few lines of code</li> <li>High Performance: Utilizes aria2 downloader under the hood, achieving 16-22 time series downloads per second</li> <li>Multimodal Support: Seamlessly integrates optical satellites, radar sensors, and derived products</li> <li>Vegetation/Agricultural Focus: Optimized for crop monitoring, vegetation analysis, and land use applications</li> <li>GeoPandas Integration: Built to work natively with spatial geodataframes</li> </ul>"},{"location":"#quick-start-example","title":"Quick Start Example","text":"<p>To download and view a cloud-free Sentinel-2 time series for a specific field and date range:</p> <pre><code>import agrigee_lite as agl\nimport geopandas as gpd\nimport ee\n\nee.Initialize()\n\n# Load your area of interest\ngdf = gpd.read_parquet(\"data/sample.parquet\")\ngeometry = gdf.iloc[0].geometry\n\n# Define satellite and download time series\nsatellite = agl.sat.Sentinel2(bands=[\"red\", \"green\", \"blue\"])\ntime_series = agl.get.sits(geometry, \"2022-10-01\", \"2023-10-01\", satellite)\n</code></pre> <p>This example demonstrates the library's core philosophy: spatial data analysis should be simple and fast. The entire library is designed to work seamlessly with GeoPandas, making it essential to have basic knowledge of this framework.</p>"},{"location":"#advanced-capabilities","title":"Advanced Capabilities","text":"<p>You can also download temporal aggregations, such as spatial median aggregations of vegetation indices from multiple satellites:</p> <p></p> <p>For synchronized multi-satellite analysis, you can use the TwoSatelliteFusion class:</p> <pre><code># Combine Landsat 8 and Sentinel-2 data for synchronized analysis\nlandsat8 = agl.sat.Landsat8(bands=[\"red\", \"green\", \"blue\", \"nir\"])\nsentinel2 = agl.sat.Sentinel2(bands=[\"red\", \"green\", \"blue\", \"nir\"])\nfusion_sat = agl.sat.TwoSatelliteFusion(landsat8, sentinel2)\n\n# Download synchronized time series with both satellites' data\nfused_time_series = agl.get.sits(geometry, \"2022-01-01\", \"2022-12-31\", fusion_sat)\n</code></pre> <p>For more comprehensive examples, see the examples folder.</p>"},{"location":"#high-performance-downloads-with-aria2","title":"High-Performance Downloads with aria2","text":"<p>One of AgriGEE.lite's key features is its use of aria2, a lightweight multi-protocol &amp; multi-source command-line download utility. This integration provides:</p> <ul> <li>Parallel Downloads: Multiple simultaneous connections for faster data retrieval</li> <li>Resume Capability: Automatic resumption of interrupted downloads</li> <li>Optimized Performance: Achieving 16-22 time series per second (for 1-year cloud-free Sentinel-2 BOA series)</li> <li>Reliability: Robust error handling and retry mechanisms</li> </ul> <p>The aria2 integration runs transparently behind the scenes, requiring no additional configuration from users while dramatically improving download speeds compared to traditional sequential downloading methods.</p>"},{"location":"#library-architecture","title":"Library Architecture","text":"<p>AgriGEE.lite is organized into three main modules:</p> <ul> <li> <p>agl.sat = Data sources, usually coming from satellites/sensors. When defining a sensor, it is possible to choose which bands you want to view/download, or whether you want to use atmospheric corrections or not. By default, all bands are downloaded, and all atmospheric corrections and harmonizations are used.</p> </li> <li> <p>agl.vis = Module that allows you to view data, either through time series or images.</p> </li> <li> <p>agl.get = Module that allows you to download data on a large scale.</p> </li> </ul>"},{"location":"#available-data-sources-satellites-sensors-models-and-so-on","title":"Available data sources (satellites, sensors, models and so on)","text":"Name Bands Start Date End Date Regionality Pixel Size Revisit Time Variations Sentinel 2 Blue, Green, Red, Re1, Re2, Re3, Nir, Re4, Swir1, Swir2 2016-01-01 (still operational) Worldwide 10 -- 60 5 days BOA, TOA Landsat 5 Blue, Green, Red, Nir, Swir1, Swir2 1984-03-01 2013-05-05 Worldwide* 15 -- 30 16 days BOA, TOA; Tier 1 and Tier 2; Landsat 7 Blue, Green, Red, Nir, Swir1, Swir2, Pan 1999-04-15 2022-04-06 Worldwide* 15 -- 30 16 days BOA, TOA; Tier 1 and Tier 2; Pan-sharpened Landsat 8 Blue, Green, Red, Nir, Swir1, Swir2, Pan 2013-04-11 (still operational) Worldwide 15 -- 30 16 days BOA, TOA; Tier 1 and Tier 2; Pan-sharpened Landsat 9 Blue, Green, Red, Nir, Swir1, Swir2, Pan 2021-11-01 (still operational) Worldwide 15 -- 30 16 days BOA, TOA; Tier 1 and Tier 2; Pan-sharpened MODIS Daily, 8 days Red, Nir 2000-02-18 (still operational) Worldwide 15 -- 30 daily/8 days Sentinel 1 VV, VH - C Band 2014-10-03 (still operational) Worldwide* 10** 5 days**** GRD, ARD*** JAXOS PalSAR 1/2 HH, HV - L Band 2014-08-04 (still operational) Worldwide 25** 15 days GRD Satellite Embeddings V1 64-dimensional embedding 2017-01-01 2024-01-01 Worldwide 10 1 year Mapbiomas Brazil 37 Land Usage Land Cover Classes 1985-01-01 2024-12-31 Brazil 30 1 year ANADEM Slope, Elevation, Aspect (single image) (single image) South America 30** (single image) SoilGrids classes WRB Soil Classes (30 categories) (single image) (single image) Worldwide 250 (single image) Two Satellite Fusion * Intersect common observations from two satellites (depends on input satellites) (depends on input satellites) (depends on input satellites) (finest of the two satellites) (depends on input satellites)"},{"location":"#observations","title":"Observations","text":"<ul> <li>*Landsat 7 images began to have artifacts caused by a sensor problem from 2003-05-31.</li> <li>**Pixel size/spatial resolution for active sensors (or models that use active sensors) often lacks a clear value, as it depends on the angle of incidence. Here, the GEE value itself is explained, representing the highest resolution captured.</li> <li>***Analysis Ready Data (ARD) is an advanced post-processing method applied to a SAR. However, it is quite costly, and its usefulness must be evaluated on a case-by-case basis.</li> <li>****Sentinel 1 was a twin satellite, one of which went out of service due to a malfunction. Therefore, the revisit time varies greatly depending on the desired geolocation.</li> <li>*Two Satellite Fusion is a meta-satellite that combines data from exactly two optical satellites (e.g., Landsat 8 + Sentinel-2). It automatically finds common observation dates, harmonizes the datasets, and creates synchronized time series with bands from both satellites distinguished by prefixes.</li> </ul>"},{"location":"#available-indices","title":"Available indices","text":"Index Name Full Name Required Bands Sensor Type Equation Description NDVI Normalized Difference Vegetation Index NIR, RED Optical \\(\\frac{NIR - RED}{NIR + RED}\\) Vegetation greenness GNDVI Green Normalized Difference Vegetation Index NIR, GREEN Optical \\(\\frac{NIR - GREEN}{NIR + GREEN}\\) Vegetation health (chlorophyll) NDWI Normalized Difference Water Index NIR, SWIR1 Optical \\(\\frac{NIR - SWIR1}{NIR + SWIR1}\\) Water content MNDWI Modified Normalized Difference Water Index GREEN, SWIR1 Optical \\(\\frac{GREEN - SWIR1}{GREEN + SWIR1}\\) Water body detection SAVI Soil Adjusted Vegetation Index NIR, RED Optical \\(\\frac{(NIR - RED)}{(NIR + RED + 0.5)} \\times 1.5\\) Vegetation, reduces soil effect EVI Enhanced Vegetation Index NIR, RED, BLUE Optical \\(2.5 \\times \\frac{NIR - RED}{NIR + 6 \\times RED - 7.5 \\times BLUE + 1}\\) Vegetation, minimizes atmospheric effects EVI2 Two-band Enhanced Vegetation Index NIR, RED Optical \\(2.5 \\times \\frac{NIR - RED}{NIR + 2.4 \\times RED + 1}\\) Simplified EVI, no blue band MSAVI Modified Soil Adjusted Vegetation Index NIR, RED Optical \\(\\frac{2 \\times NIR + 1 - \\sqrt{(2 \\times NIR + 1)^2 - 8 \\times (NIR - RED)}}{2}\\) Vegetation in areas with bare soil NDRE Normalized Difference Red Edge Index NIR, RE1 Optical \\(\\frac{NIR - RE1}{NIR + RE1}\\) Chlorophyll content in leaves MCARI Modified Chlorophyll Absorption in Reflectance Index NIR, RED, GREEN Optical \\(\\left[(NIR - RED) - 0.2 \\times (NIR - GREEN)\\right] \\times \\frac{NIR}{RED}\\) Leaf chlorophyll content GCI Green Chlorophyll Index NIR, GREEN Optical \\(\\frac{NIR}{GREEN} - 1\\) Chlorophyll concentration BSI Bare Soil Index BLUE, RED, NIR, SWIR1 Optical \\(\\frac{(SWIR1 + RED) - (NIR + BLUE)}{(SWIR1 + RED) + (NIR + BLUE)}\\) Bare soil index CI Red Red Chlorophyll Index NIR, RED Optical \\(\\frac{NIR}{RED} - 1\\) Chlorophyll index (red) CI Green Green Chlorophyll Index NIR, GREEN Optical \\(\\frac{NIR}{GREEN} - 1\\) Chlorophyll index (green) OSAVI Optimized Soil Adjusted Vegetation Index NIR, RED Optical \\(\\frac{NIR - RED}{NIR + RED + 0.16}\\) Like SAVI, for low vegetation ARVI Atmospherically Resistant Vegetation Index NIR, RED, BLUE Optical \\(\\frac{NIR - (2 \\times RED - BLUE)}{NIR + (2 \\times RED - BLUE)}\\) Vegetation, reduces atmospheric effects VHVV VH/VV Ratio VH, VV Radar \\(\\frac{VH}{VV}\\) Vegetation structure (Sentinel-1) HHHV HH/HV Ratio HH, HV Radar \\(\\frac{HH - HV}{HH + HV}\\) Vegetation structure (PALSAR) RVI Radar Vegetation Index HH, HV Radar \\(4 \\times \\frac{HV}{HH + HV}\\) Radar vegetation index (PALSAR) RAVI Radar Adapted Vegetation Index VV, VH Radar \\(4 \\times \\frac{VH}{VV + VH}\\) Radar vegetation index (Sentinel-1)"},{"location":"#avaiable-reductors","title":"Avaiable reductors","text":"Name to Use Full Name Description min Minimum Returns the smallest value in the set max Maximum Returns the largest value in the set mean Mean Returns the average of all values median Median Returns the median (middle) value kurt Kurtosis Returns the kurtosis (measure of \"tailedness\") skew Skewness Returns the skewness (measure of asymmetry) std Standard Deviation Returns the standard deviation var Variance Returns the variance mode Mode Returns the most frequent value pXX Percentile XX Returns the XX-th percentile (e.g., <code>p10</code> for 10th percentile). You can pass multiple, e.g., <code>p10</code>, <code>p90</code>."},{"location":"#motivation-simplifying-earth-engine-for-everyone","title":"Motivation: Simplifying Earth Engine for Everyone","text":"<p>My journey with Google Earth Engine began two and a half years ago. While GEE is an incredibly powerful platform that provides access to petabytes of satellite data, it comes with significant complexity challenges:</p> <ul> <li>Steep Learning Curve: GEE requires extensive boilerplate code and deep understanding of its functional programming paradigms</li> <li>Cryptic Error Messages: Server-side execution often produces confusing errors that are difficult to debug</li> <li>Harmonization Complexity: Each satellite has different value ranges, cloud masking approaches, and preprocessing requirements</li> <li>Inconsistent APIs: Different sensors require different coding approaches, making it hard to switch between data sources</li> </ul> <p>During my master's degree, I found myself constantly rewriting similar code patterns for different projects. This frustration led to a simple but ambitious goal: making satellite data as easy to use as reading a CSV with pandas, without requiring users to be remote sensing experts.</p>"},{"location":"#objectives-and-target-audience","title":"Objectives and Target Audience","text":"<p>AgriGEE.lite aims to be a simple, direct, and high-performance solution for downloading satellite data, serving both academic research and commercial applications. The library is designed for:</p> <ul> <li>Data Scientists who need satellite data but don't want to become GEE experts</li> <li>Agricultural Researchers studying crop monitoring and vegetation dynamics</li> <li>Environmental Consultants requiring rapid access to earth observation data</li> <li>Students and Educators learning remote sensing applications</li> <li>Commercial Users developing scalable earth observation solutions</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Found this project helpful? \u2b50 Give it a star! Want to contribute? \ud83d\ude80 Open a Pull Request - we welcome all contributions!</p>"},{"location":"#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"#why-use-google-earth-engine-instead-of-stac","title":"Why use Google Earth Engine instead of STAC?","text":"<p>While STAC (SpatioTemporal Asset Catalog) is an excellent approach that makes sense for large-scale infrastructure projects, processing satellite data locally can quickly become overwhelming, especially for regions with vast agricultural areas like Australia, the United States, or Brazil.</p> <p>Key considerations: - Infrastructure Costs: Building and maintaining your own processing infrastructure vs. GEE usage costs - Processing Complexity: GEE handles complex atmospheric corrections, cloud masking, and data harmonization automatically - Scalability: GEE's planetary-scale computing capabilities vs. local processing limitations - Free Tier: GEE is completely free for academic research and non-commercial projects</p> <p>The choice depends on your specific use case, scale, and budget requirements.</p>"},{"location":"#about-terminology-satellites-vs-sensors","title":"About Terminology: \"Satellites\" vs. \"Sensors\"","text":"<p>Remote sensing experts often note that terms like \"satellite\" for radar data or \"bands\" for SAR aren't technically precise. However, we've chosen standardized terminology to:</p> <ul> <li>Simplify the API: Consistent naming across all data sources reduces cognitive load</li> <li>Improve Accessibility: Non-experts can work with different sensors using the same patterns</li> <li>Maintain Code Consistency: Unified interfaces make the library easier to maintain and extend</li> </ul> <p>Even excellent projects like MapBiomas (which uses models and algorithms) are treated as \"satellites\" in our framework. We welcome technical accuracy improvements, but prioritize usability and consistency. Your contributions to improve both aspects are very welcome!</p>"},{"location":"#about-our-mascot","title":"About Our Mascot","text":"<p>The AgriGEE.lite mascot was created using AI tools, with artwork inspired by the \"Odd-Eyes Venom Dragon\" from Yu-Gi-Oh. The symbolism represents:</p> <ul> <li>\ud83c\udf31 Plant Dragon: Agricultural focus</li> <li>\ud83d\udd00 Fusion Card: Multimodal data integration</li> <li>\ud83d\udc40 Odd-Eyes: Multiple satellite perspectives on Earth</li> </ul> <p>If you're an artist interested in creating a new mascot design, we'd love to make it official!</p>"},{"location":"#known-bugs","title":"Known Bugs","text":"<ul> <li>QuadTree clustering functions produce absurd results when there are very uneven geographic density distributions, for example, thousands of points in one country and a few dozen in another. Some prior geospatial partitioning is recommended.</li> </ul>"},{"location":"#development-roadmap","title":"Development Roadmap","text":""},{"location":"#completed-features","title":"\u2705 Completed Features","text":"<ul> <li>[x] Optical Satellites: Sentinel-2, Landsat 5/7/8/9 support</li> <li>[x] Radar Sensors: Sentinel-1 GRD, ALOS-2 PALSAR-2</li> <li>[x] Derived Products: MapBiomas Brazil, MODIS Terra/Aqua</li> <li>[x] Time Series: Satellite Image Time Series (SITS) with aggregations</li> <li>[x] Downloads: Online and task-based download methods with aria2 integration</li> <li>[x] Visualizations: matplotlib-based plotting for images and time series</li> <li>[x] Cloud Recovery: smart_open[gcs] integration for automatic data recovery</li> <li>[x] Advanced Processing: Configurable cloud masking, Landsat pan-sharpening</li> </ul>"},{"location":"#in-development","title":"\ud83d\udea7 In Development","text":"<ul> <li>[ ] Enhanced Visualizations: plotly-based interactive plotting</li> <li>[ ] Expanded Coverage: All MapBiomas collections (Amazon, Cerrado, etc.)</li> <li>[ ] Advanced Radar: Sentinel-1 ARD (Analysis Ready Data)</li> <li>[ ] Ocean Monitoring: Sentinel-3 OLCI/SLSTR sensors</li> <li>[ ] Historical Data: Landsat 1-4 for long-term analysis</li> </ul>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#agrigee_lite.ee_quick_start","title":"<code>ee_quick_start()</code>","text":"<p>Quick start function to initialize Earth Engine with automatic credential detection.</p> <p>Automatically detects and uses Earth Engine credentials from the GEE_KEY environment variable. Supports both service account JSON files and project tokens, providing informative feedback about the initialization process.</p> Environment Variables <p>GEE_KEY : str     Earth Engine authentication key. Can be either:     - Path to service account JSON file (ends with .json)     - Project token string for standard authentication</p> <p>Returns:</p> Type Description <code>None</code> <p>Prints initialization status messages but doesn't return values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; os.environ['GEE_KEY'] = '/path/to/service-account.json'\n&gt;&gt;&gt; ee_quick_start()\nEarth Engine initialized successfully using AgriGEE.lite...\n</code></pre> Notes <p>For service account authentication, the function also sets the GOOGLE_APPLICATION_CREDENTIALS environment variable for use Google Cloud Storage.</p> Source code in <code>agrigee_lite/ee_utils.py</code> <pre><code>def ee_quick_start() -&gt; None:\n    \"\"\"\n    Quick start function to initialize Earth Engine with automatic credential detection.\n\n    Automatically detects and uses Earth Engine credentials from the GEE_KEY\n    environment variable. Supports both service account JSON files and project\n    tokens, providing informative feedback about the initialization process.\n\n    Environment Variables\n    ---------------------\n    GEE_KEY : str\n        Earth Engine authentication key. Can be either:\n        - Path to service account JSON file (ends with .json)\n        - Project token string for standard authentication\n\n    Returns\n    -------\n    None\n        Prints initialization status messages but doesn't return values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import os\n    &gt;&gt;&gt; os.environ['GEE_KEY'] = '/path/to/service-account.json'\n    &gt;&gt;&gt; ee_quick_start()\n    Earth Engine initialized successfully using AgriGEE.lite...\n\n    Notes\n    -----\n    For service account authentication, the function also sets the\n    GOOGLE_APPLICATION_CREDENTIALS environment variable for use Google Cloud Storage.\n    \"\"\"\n\n    if not ee_is_authenticated():\n        if \"GEE_KEY\" in os.environ:\n            gee_key = os.environ[\"GEE_KEY\"]\n\n            if gee_key.endswith(\".json\"):  # with service account\n                credentials = ee.ServiceAccountCredentials(gee_key, gee_key)\n                ee.Initialize(credentials)\n\n                os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = gee_key\n\n                with open(gee_key) as f:\n                    key_data = json.load(f)\n                    print(\n                        f\"Earth Engine initialized successfully using AgriGEE.lite with service account. Project: {key_data.get('project_id', 'Unknown')}, Email: {key_data.get('client_email', 'Unknown')}.\"\n                    )\n\n            else:  # using token\n                ee.Initialize(opt_url=\"https://earthengine-highvolume.googleapis.com\", project=gee_key)\n                print(f\"Earth Engine initialized successfully using AgriGEE.lite using token (project={gee_key}).\")\n\n        else:\n            print(\n                \"Earth Engine not initialized. Please set the GEE_KEY environment variable to your Earth Engine key. You can find more information in the AgriGEE.lite documentation.\"\n            )\n</code></pre>"},{"location":"modules/#agrigee_lite.get_all_tasks","title":"<code>get_all_tasks()</code>","text":"<p>Retrieve status information for all Earth Engine tasks.</p> <p>Fetches comprehensive information about all Earth Engine operations/tasks associated with the authenticated account, including metadata, timing, resource usage, and cost estimates.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing task information with the following columns: - attempt: Task attempt number - create_time: Task creation timestamp - description: Task description/name - destination_uris: Output destination URIs - done: Boolean indicating completion status - end_time: Task completion timestamp - name: Internal task name - priority: Task priority level - progress: Completion progress (0.0 to 1.0) - script_uri: Source script URI - start_time: Task start timestamp - state: Current task state (RUNNING, COMPLETED, FAILED, etc.) - total_batch_eecu_usage_seconds: Total EECU usage in seconds - type: Task type (EXPORT_IMAGE, EXPORT_TABLE, etc.) - update_time: Last update timestamp - estimated_cost_usd_tier_1: Estimated cost in US Dollars for Tier 1 pricing - estimated_cost_usd_tier_2: Estimated cost in US Dollars for Tier 2 pricing - estimated_cost_usd_tier_3: Estimated cost in US Dollars for Tier 3 pricing</p> Notes <p>Cost estimates are based on EECU usage and standard pricing tiers. If no tasks exist, returns an empty DataFrame with the same column structure.</p> Source code in <code>agrigee_lite/ee_utils.py</code> <pre><code>def ee_get_tasks_status() -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieve status information for all Earth Engine tasks.\n\n    Fetches comprehensive information about all Earth Engine operations/tasks\n    associated with the authenticated account, including metadata, timing,\n    resource usage, and cost estimates.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame containing task information with the following columns:\n        - attempt: Task attempt number\n        - create_time: Task creation timestamp\n        - description: Task description/name\n        - destination_uris: Output destination URIs\n        - done: Boolean indicating completion status\n        - end_time: Task completion timestamp\n        - name: Internal task name\n        - priority: Task priority level\n        - progress: Completion progress (0.0 to 1.0)\n        - script_uri: Source script URI\n        - start_time: Task start timestamp\n        - state: Current task state (RUNNING, COMPLETED, FAILED, etc.)\n        - total_batch_eecu_usage_seconds: Total EECU usage in seconds\n        - type: Task type (EXPORT_IMAGE, EXPORT_TABLE, etc.)\n        - update_time: Last update timestamp\n        - estimated_cost_usd_tier_1: Estimated cost in US Dollars for Tier 1 pricing\n        - estimated_cost_usd_tier_2: Estimated cost in US Dollars for Tier 2 pricing\n        - estimated_cost_usd_tier_3: Estimated cost in US Dollars for Tier 3 pricing\n\n    Notes\n    -----\n    Cost estimates are based on EECU usage and standard pricing tiers.\n    If no tasks exist, returns an empty DataFrame with the same column structure.\n    \"\"\"\n    tasks = ee.data.listOperations()\n\n    if tasks:\n        records = []\n        for op in tasks:\n            metadata = op.get(\"metadata\", {})\n\n            record = {\n                \"attempt\": metadata.get(\"attempt\"),\n                \"create_time\": metadata.get(\"createTime\"),\n                \"description\": metadata.get(\"description\"),\n                \"destination_uris\": metadata.get(\"destinationUris\", [None])[0],\n                \"done\": op.get(\"done\"),\n                \"end_time\": metadata.get(\"endTime\"),\n                \"name\": op.get(\"name\"),\n                \"priority\": metadata.get(\"priority\"),\n                \"progress\": metadata.get(\"progress\"),\n                \"script_uri\": metadata.get(\"scriptUri\"),\n                \"start_time\": metadata.get(\"startTime\"),\n                \"state\": metadata.get(\"state\"),\n                \"total_batch_eecu_usage_seconds\": metadata.get(\"batchEecuUsageSeconds\", 0.0),\n                \"type\": metadata.get(\"type\"),\n                \"update_time\": metadata.get(\"updateTime\"),\n            }\n            records.append(record)\n\n        df = pd.DataFrame(records)\n        df[\"create_time\"] = pd.to_datetime(df.create_time, format=\"mixed\")\n        df[\"end_time\"] = pd.to_datetime(df.end_time, format=\"mixed\")\n        df[\"start_time\"] = pd.to_datetime(df.start_time, format=\"mixed\")\n        df[\"update_time\"] = pd.to_datetime(df.update_time, format=\"mixed\")\n\n        df[\"estimated_cost_usd_tier_1\"] = (df.total_batch_eecu_usage_seconds / (60 * 60)) * 0.40\n        df[\"estimated_cost_usd_tier_2\"] = (df.total_batch_eecu_usage_seconds / (60 * 60)) * 0.28\n        df[\"estimated_cost_usd_tier_3\"] = (df.total_batch_eecu_usage_seconds / (60 * 60)) * 0.16\n\n    else:  # If no tasks are found, create an empty DataFrame with the same columns\n        df = pd.DataFrame(\n            columns=[\n                \"attempt\",\n                \"create_time\",\n                \"description\",\n                \"destination_uris\",\n                \"done\",\n                \"end_time\",\n                \"name\",\n                \"priority\",\n                \"progress\",\n                \"script_uri\",\n                \"start_time\",\n                \"state\",\n                \"total_batch_eecu_usage_seconds\",\n                \"type\",\n                \"update_time\",\n            ]\n        )\n\n    return df\n</code></pre>"},{"location":"modules/#agrigee_lite.quadtree_clustering","title":"<code>quadtree_clustering(gdf, max_size=1000)</code>","text":"<p>Cluster geometries in a GeoDataFrame using a quadtree and simplify clusters.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing geometries (Polygon, MultiPolygon, or Point).</p> required <code>max_size</code> <code>int</code> <p>Maximum number of geometries per cluster (default is 1000).</p> <code>1000</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame with cluster labels and simplified geometries.</p> Source code in <code>agrigee_lite/misc.py</code> <pre><code>def quadtree_clustering(gdf: gpd.GeoDataFrame, max_size: int = 1000) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Cluster geometries in a GeoDataFrame using a quadtree and simplify clusters.\n\n    Parameters\n    ----------\n    gdf : geopandas.GeoDataFrame\n        GeoDataFrame containing geometries (Polygon, MultiPolygon, or Point).\n    max_size : int, optional\n        Maximum number of geometries per cluster (default is 1000).\n\n    Returns\n    -------\n    geopandas.GeoDataFrame\n        GeoDataFrame with cluster labels and simplified geometries.\n    \"\"\"\n    gdf = gdf.copy()\n\n    # Centroid columns (ignore CRS warning)\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", category=UserWarning)\n        gdf[\"centroid_x\"] = gdf.geometry.centroid.x\n        gdf[\"centroid_y\"] = gdf.geometry.centroid.y\n\n    # Build quadtree and label clusters\n    clusters = build_quadtree_iterative(gdf, max_size=max_size)\n\n    cluster_array = np.zeros(len(gdf), dtype=int)\n    for i, cluster_indexes in enumerate(clusters):\n        cluster_array[cluster_indexes] = i\n\n    gdf[\"cluster_id\"] = cluster_array\n    gdf = gdf.sort_values(by=[\"cluster_id\", \"centroid_x\"]).reset_index(drop=True)\n\n    unique_cluster_ids = gdf[\"cluster_id\"].unique()\n\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        futures = {\n            executor.submit(_simplify_cluster, gdf[gdf.cluster_id == cluster_id][[\"geometry\"]], cluster_id): cluster_id\n            for cluster_id in unique_cluster_ids\n        }\n\n        for future in tqdm(\n            concurrent.futures.as_completed(futures),\n            total=len(futures),\n            desc=\"Simplifying clusters\",\n            smoothing=0.5,\n        ):\n            cluster_id, simplified_geom = future.result()\n            gdf.loc[gdf[\"cluster_id\"] == cluster_id, \"geometry\"] = simplified_geom.values\n\n    return gdf\n</code></pre>"},{"location":"modules/#agrigee_lite.random_points_from_gdf","title":"<code>random_points_from_gdf(gdf, num_points_per_geometry=10, buffer=-10)</code>","text":"<p>Generate random points from geometries in a GeoDataFrame, with optional buffering.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing geometries (Polygon, MultiPolygon, or Point).</p> required <code>num_points_per_geometry</code> <code>int</code> <p>Number of points to generate per geometry (default is 10).</p> <code>10</code> <code>buffer</code> <code>int</code> <p>Buffer distance to apply to geometries before generating points (default is -10).</p> <code>-10</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>GeoDataFrame of generated points merged with original attributes.</p> Source code in <code>agrigee_lite/misc.py</code> <pre><code>def random_points_from_gdf(\n    gdf: gpd.GeoDataFrame, num_points_per_geometry: int = 10, buffer: int = -10\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Generate random points from geometries in a GeoDataFrame, with optional buffering.\n\n    Parameters\n    ----------\n    gdf : geopandas.GeoDataFrame\n        GeoDataFrame containing geometries (Polygon, MultiPolygon, or Point).\n    num_points_per_geometry : int, optional\n        Number of points to generate per geometry (default is 10).\n    buffer : int, optional\n        Buffer distance to apply to geometries before generating points (default is -10).\n\n    Returns\n    -------\n    geopandas.GeoDataFrame\n        GeoDataFrame of generated points merged with original attributes.\n    \"\"\"\n    if buffer != 0:\n        gdf = gdf.copy()\n        gdf = quadtree_clustering(gdf)\n        gdf[\"geometry\"] = gdf.to_crs(gdf.estimate_utm_crs()).buffer(-10).to_crs(\"EPSG:4326\")\n\n    gdf[\"geometry_id\"] = pd.factorize(gdf[\"geometry\"])[0]\n    points_gdf = generate_grid_random_points_from_gdf(gdf, num_points_per_geometry)\n    points_gdf = points_gdf.merge(\n        gdf.drop(columns=[\"geometry\"]).reset_index().rename(columns={\"index\": \"original_index\"}),\n        on=\"geometry_id\",\n        how=\"inner\",\n    )\n    points_gdf = points_gdf[points_gdf.geometry.x != 0].reset_index(drop=True)\n\n    return points_gdf\n</code></pre>"},{"location":"modules/#agrigee_lite.get.images","title":"<code>images(geometry, start_date, end_date, satellite, invalid_images_threshold=0.5, max_parallel_downloads=40, force_redownload=False, image_indices=None)</code>","text":"<p>Download multiple satellite images for a given geometry and date range.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Polygon or MultiPolygon</code> <p>The area of interest as a shapely Polygon or MultiPolygon.</p> required <code>start_date</code> <code>Timestamp or str</code> <p>Start date for image collection.</p> required <code>end_date</code> <code>Timestamp or str</code> <p>End date for image collection.</p> required <code>satellite</code> <code>AbstractSatellite</code> <p>The satellite configuration to use for image collection.</p> required <code>invalid_images_threshold</code> <code>float</code> <p>Threshold for filtering images based on valid pixels (0.0-1.0), by default 0.5.</p> <code>0.5</code> <code>max_parallel_downloads</code> <code>int</code> <p>Maximum number of parallel downloads, by default 40.</p> <code>40</code> <code>force_redownload</code> <code>bool</code> <p>Whether to force re-download of existing files, by default False.</p> <code>False</code> <code>image_indices</code> <code>list[int] or None</code> <p>List of specific image indices to download (e.g., [0, 1] for first two images). If None, all images in the date range will be downloaded, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of image names (dates in YYYY-MM-DD format) that were downloaded.</p> Source code in <code>agrigee_lite/get/image.py</code> <pre><code>def download_multiple_images(  # noqa: C901\n    geometry: Polygon | MultiPolygon,\n    start_date: pd.Timestamp | str,\n    end_date: pd.Timestamp | str,\n    satellite: AbstractSatellite,\n    invalid_images_threshold: float = 0.5,\n    max_parallel_downloads: int = 40,\n    force_redownload: bool = False,\n    image_indices: list[int] | None = None,\n) -&gt; list[str]:\n    \"\"\"\n    Download multiple satellite images for a given geometry and date range.\n\n    Parameters\n    ----------\n    geometry : Polygon or MultiPolygon\n        The area of interest as a shapely Polygon or MultiPolygon.\n    start_date : pd.Timestamp or str\n        Start date for image collection.\n    end_date : pd.Timestamp or str\n        End date for image collection.\n    satellite : AbstractSatellite\n        The satellite configuration to use for image collection.\n    invalid_images_threshold : float, optional\n        Threshold for filtering images based on valid pixels (0.0-1.0), by default 0.5.\n    max_parallel_downloads : int, optional\n        Maximum number of parallel downloads, by default 40.\n    force_redownload : bool, optional\n        Whether to force re-download of existing files, by default False.\n    image_indices : list[int] or None, optional\n        List of specific image indices to download (e.g., [0, 1] for first two images).\n        If None, all images in the date range will be downloaded, by default None.\n\n    Returns\n    -------\n    list[str]\n        List of image names (dates in YYYY-MM-DD format) that were downloaded.\n    \"\"\"\n\n    start_date = start_date.strftime(\"%Y-%m-%d\") if isinstance(start_date, pd.Timestamp) else start_date\n    end_date = end_date.strftime(\"%Y-%m-%d\") if isinstance(end_date, pd.Timestamp) else end_date\n\n    ee_geometry = ee.Geometry(geometry.__geo_interface__)\n    ee_feature = ee.Feature(\n        ee_geometry,\n        {\"s\": start_date, \"e\": end_date, \"0\": 1},\n    )\n    ee_expression = satellite.imageCollection(ee_feature)\n\n    metadata_dict: dict[str, str] = {}\n    metadata_dict |= log_dict_function_call_summary([\n        \"geometry\",\n        \"start_date\",\n        \"end_date\",\n        \"satellite\",\n        \"max_parallel_downloads\",\n        \"force_redownload\",\n    ])\n    metadata_dict |= satellite.log_dict()\n    metadata_dict[\"start_date\"] = start_date\n    metadata_dict[\"end_date\"] = end_date\n    metadata_dict[\"centroid_x\"] = geometry.centroid.x\n    metadata_dict[\"centroid_y\"] = geometry.centroid.y\n\n    if ee_expression.size().getInfo() == 0:\n        print(\"No images found for the specified parameters.\")\n        return np.array([]), []\n\n    max_valid_pixels = ee_expression.aggregate_max(\"ZZ_USER_VALID_PIXELS\")\n    threshold = ee.Number(max_valid_pixels).multiply(invalid_images_threshold)\n    ee_expression = ee_expression.filter(ee.Filter.gte(\"ZZ_USER_VALID_PIXELS\", threshold))\n\n    image_names = ee_expression.aggregate_array(\"ZZ_USER_TIME_DUMMY\").getInfo()\n    image_indexes = ee_expression.aggregate_array(\"system:index\").getInfo()\n\n    # Filter images by indices if provided\n    if image_indices is not None:\n        # Ensure indices are valid\n        valid_indices = [i for i in image_indices if 0 &lt;= i &lt; len(image_indexes)]\n        if not valid_indices:\n            print(\"No valid image indices provided.\")\n            return np.array([]), []\n\n        image_names = [image_names[i] for i in valid_indices]\n        image_indexes = [image_indexes[i] for i in valid_indices]\n\n    output_path = pathlib.Path(\"data/temp/images\") / f\"{create_dict_hash(metadata_dict)}\"\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    if force_redownload:\n        for f in output_path.glob(\"*.zip\"):\n            f.unlink()\n\n    downloader = DownloaderStrategy(download_folder=output_path)\n\n    already_downloaded_files = {int(x.stem) for x in output_path.glob(\"*.zip\")}\n    all_chunks = set(range(len(image_indexes)))\n    pending_chunks = sorted(all_chunks - already_downloaded_files)\n\n    pbar = tqdm(total=len(pending_chunks), desc=f\"Downloading images ({output_path.name})\", unit=\"feature\")\n\n    def update_pbar():\n        pbar.n = downloader.num_completed_downloads\n        pbar.refresh()\n        pbar.set_postfix({\n            \"aria2_errors\": downloader.num_downloads_with_error,\n            \"active_downloads\": downloader.num_unfinished_downloads,\n        })\n\n    def download_task(chunk_index):\n        try:\n            img = ee.Image(ee_expression.filter(ee.Filter.eq(\"system:index\", image_indexes[chunk_index])).first())\n            # Use only the image date as filename (GEE standard format)\n            image_date = image_names[chunk_index]\n            filename = f\"{image_date}\"\n            url = img.getDownloadURL({\"name\": filename, \"region\": ee_geometry})\n            downloader.add_download([(chunk_index, url)])\n            return chunk_index, True  # noqa: TRY300\n        except Exception as _:\n            return chunk_index, False\n\n    while downloader.num_completed_downloads &lt; len(pending_chunks):\n        with ThreadPoolExecutor(max_workers=max_parallel_downloads) as executor:\n            futures = {executor.submit(download_task, chunk): chunk for chunk in pending_chunks}\n\n            failed_chunks = []\n            for future in as_completed(futures):\n                chunk, success = future.result()\n                if not success:\n                    failed_chunks.append(chunk)\n                    logging.warning(f\"Download images - {output_path} - Failed to initiate download for chunk {chunk}.\")\n\n                update_pbar()\n\n                while downloader.num_unfinished_downloads &gt;= max_parallel_downloads:\n                    time.sleep(1)\n                    update_pbar()\n\n        while downloader.num_unfinished_downloads &gt; 0:\n            time.sleep(1)\n            update_pbar()\n\n        pending_chunks = sorted(set(failed_chunks + downloader.failed_downloads))\n\n    update_pbar()\n    pbar.close()\n\n    return image_names\n</code></pre>"},{"location":"modules/#agrigee_lite.get.multiple_sits","title":"<code>multiple_sits(gdf, satellite, reducers=None, original_index_column_name='original_index', start_date_column_name='start_date', end_date_column_name='end_date', subsampling_max_pixels=1000, chunksize=10, max_parallel_downloads=40, force_redownload=False)</code>","text":"<p>Download satellite time series for multiple geometries using parallel processing.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing geometries and temporal information.</p> required <code>satellite</code> <code>AbstractSatellite</code> <p>Satellite configuration object.</p> required <code>reducers</code> <code>set[str] or None</code> <p>Set of reducer names to apply, by default None.</p> <code>None</code> <code>original_index_column_name</code> <code>str</code> <p>Name of the column to store original indices, by default \"original_index\".</p> <code>'original_index'</code> <code>start_date_column_name</code> <code>str</code> <p>Name of the start date column, by default \"start_date\".</p> <code>'start_date'</code> <code>end_date_column_name</code> <code>str</code> <p>Name of the end date column, by default \"end_date\".</p> <code>'end_date'</code> <code>subsampling_max_pixels</code> <code>float</code> <p>Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.</p> <code>1000</code> <code>chunksize</code> <code>int</code> <p>Number of features to process per chunk, by default 10.</p> <code>10</code> <code>max_parallel_downloads</code> <code>int</code> <p>Maximum number of parallel downloads, by default 40.</p> <code>40</code> <code>force_redownload</code> <code>bool</code> <p>Whether to force re-download of existing data, by default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Combined DataFrame containing satellite time series for all geometries.</p> Source code in <code>agrigee_lite/get/sits.py</code> <pre><code>def download_multiple_sits(  # noqa: C901\n    gdf: gpd.GeoDataFrame,\n    satellite: AbstractSatellite,\n    reducers: set[str] | None = None,\n    original_index_column_name: str = \"original_index\",\n    start_date_column_name: str = \"start_date\",\n    end_date_column_name: str = \"end_date\",\n    subsampling_max_pixels: float = 1_000,\n    chunksize: int = 10,\n    max_parallel_downloads: int = 40,\n    force_redownload: bool = False,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Download satellite time series for multiple geometries using parallel processing.\n\n    Parameters\n    ----------\n    gdf : gpd.GeoDataFrame\n        GeoDataFrame containing geometries and temporal information.\n    satellite : AbstractSatellite\n        Satellite configuration object.\n    reducers : set[str] or None, optional\n        Set of reducer names to apply, by default None.\n    original_index_column_name : str, optional\n        Name of the column to store original indices, by default \"original_index\".\n    start_date_column_name : str, optional\n        Name of the start date column, by default \"start_date\".\n    end_date_column_name : str, optional\n        Name of the end date column, by default \"end_date\".\n    subsampling_max_pixels : float, optional\n        Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.\n    chunksize : int, optional\n        Number of features to process per chunk, by default 10.\n    max_parallel_downloads : int, optional\n        Maximum number of parallel downloads, by default 40.\n    force_redownload : bool, optional\n        Whether to force re-download of existing data, by default False.\n\n    Returns\n    -------\n    pd.DataFrame\n        Combined DataFrame containing satellite time series for all geometries.\n    \"\"\"\n    if len(gdf) == 0:\n        return pd.DataFrame()\n\n    gdf = sanitize_and_prepare_input_gdf(\n        gdf, satellite, original_index_column_name, 1000, start_date_column_name, end_date_column_name\n    )\n\n    metadata_dict: dict[str, str] = {}\n    metadata_dict |= log_dict_function_call_summary([\"gdf\", \"satellite\", \"max_parallel_downloads\", \"force_redownload\"])\n    metadata_dict |= satellite.log_dict()\n\n    output_path = (\n        pathlib.Path(\"data/temp/sits\")\n        / f\"{create_gdf_hash(gdf, start_date_column_name, end_date_column_name)}_{create_dict_hash(metadata_dict)}\"\n    )\n\n    if force_redownload:\n        for f in output_path.glob(\"*\"):\n            f.unlink()\n\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    downloader = DownloaderStrategy(download_folder=output_path)\n\n    num_chunks = (len(gdf) + chunksize - 1) // chunksize\n\n    already_downloaded_files = [int(x.stem) for x in output_path.glob(\"*.csv\")]\n    logging.info(output_path, \"-\", len(already_downloaded_files), \"chunks already downloaded and will be skipped.\")\n    initial_download_chunks = sorted(set(range(num_chunks)) - set(already_downloaded_files))\n\n    pbar = tqdm(\n        total=len(initial_download_chunks) * chunksize,\n        desc=f\"Building download URLs ({output_path.name})\",\n        unit=\"feature\",\n        smoothing=0,\n    )\n\n    def update_pbar():\n        pbar.n = downloader.num_completed_downloads * chunksize\n        pbar.refresh()\n        pbar.set_postfix({\n            \"not_sent_to_server\": len(not_sent_to_server),\n            \"aria2_errors\": downloader.num_downloads_with_error,\n            \"active_downloads\": downloader.num_unfinished_downloads,\n        })\n\n    to_download_chunks = initial_download_chunks\n    while downloader.num_completed_downloads != len(initial_download_chunks):\n        not_sent_to_server = []\n\n        for current_chunk in to_download_chunks:\n            while downloader.num_unfinished_downloads &gt;= max_parallel_downloads:\n                time.sleep(1)\n                update_pbar()\n\n            sub = gdf.iloc[current_chunk * chunksize : (current_chunk + 1) * chunksize]\n            ee_expression = build_ee_expression(\n                sub,\n                satellite,\n                reducers,\n                subsampling_max_pixels,\n                original_index_column_name,\n                start_date_column_name,\n                end_date_column_name,\n            )\n\n            try:\n                url = ee_expression.getDownloadURL(\n                    filetype=\"csv\",\n                    selectors=build_selectors(satellite, reducers),\n                    filename=f\"{current_chunk}\",\n                )\n\n                downloader.add_download([(current_chunk, url)])\n\n            except KeyboardInterrupt:\n                pbar.close()\n                raise\n\n            except ee.ee_exception.EEException:\n                logging.exception(output_path, \"- Chunk id =\", current_chunk, \" - Failed to get download URL.\")\n                not_sent_to_server.append(current_chunk)\n\n            update_pbar()\n\n        to_download_chunks = sorted(set(not_sent_to_server) | set(downloader.failed_downloads))\n        while len(to_download_chunks) == 0 and (downloader.num_completed_downloads != len(initial_download_chunks)):\n            time.sleep(1)\n            to_download_chunks = sorted(set(not_sent_to_server) | set(downloader.failed_downloads))\n            update_pbar()\n\n    pbar.close()\n    whole_result_df = pd.DataFrame()\n    for f in output_path.glob(\"*.csv\"):\n        df = pd.read_csv(f)\n        whole_result_df = pd.concat([whole_result_df, df], ignore_index=True)\n\n    whole_result_df = prepare_output_df(whole_result_df, satellite, original_index_column_name)\n\n    return whole_result_df\n</code></pre>"},{"location":"modules/#agrigee_lite.get.multiple_sits_gcs","title":"<code>multiple_sits_gcs(gdf, satellite, bucket_name, reducers=None, original_index_column_name='original_index', start_date_column_name='start_date', end_date_column_name='end_date', subsampling_max_pixels=1000, cluster_size=500, force_redownload=False, wait=True)</code>","text":"<p>Download satellite time series using Google Earth Engine tasks to Google Cloud Storage.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing geometries and temporal information.</p> required <code>satellite</code> <code>AbstractSatellite</code> <p>Satellite configuration object.</p> required <code>bucket_name</code> <code>str</code> <p>Google Cloud Storage bucket name for exports.</p> required <code>reducers</code> <code>set[str] or None</code> <p>Set of reducer names to apply, by default None.</p> <code>None</code> <code>original_index_column_name</code> <code>str</code> <p>Name of the column to store original indices, by default \"original_index\".</p> <code>'original_index'</code> <code>start_date_column_name</code> <code>str</code> <p>Name of the start date column, by default \"start_date\".</p> <code>'start_date'</code> <code>end_date_column_name</code> <code>str</code> <p>Name of the end date column, by default \"end_date\".</p> <code>'end_date'</code> <code>subsampling_max_pixels</code> <code>float</code> <p>Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.</p> <code>1000</code> <code>cluster_size</code> <code>int</code> <p>Maximum cluster size for spatial grouping, by default 500.</p> <code>500</code> <code>force_redownload</code> <code>bool</code> <p>Whether to force re-download of existing data, by default False.</p> <code>False</code> <code>wait</code> <code>bool</code> <p>Whether to wait for task completion, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None or DataFrame</code> <p>If wait is True, returns DataFrame with combined results. If wait is False, returns None.</p> Source code in <code>agrigee_lite/get/sits.py</code> <pre><code>def download_multiple_sits_chunks_gcs(\n    gdf: gpd.GeoDataFrame,\n    satellite: AbstractSatellite,\n    bucket_name: str,\n    reducers: set[str] | None = None,\n    original_index_column_name: str = \"original_index\",\n    start_date_column_name: str = \"start_date\",\n    end_date_column_name: str = \"end_date\",\n    subsampling_max_pixels: float = 1_000,\n    cluster_size: int = 500,\n    force_redownload: bool = False,\n    wait: bool = True,\n) -&gt; None | pd.DataFrame:\n    \"\"\"\n    Download satellite time series using Google Earth Engine tasks to Google Cloud Storage.\n\n    Parameters\n    ----------\n    gdf : gpd.GeoDataFrame\n        GeoDataFrame containing geometries and temporal information.\n    satellite : AbstractSatellite\n        Satellite configuration object.\n    bucket_name : str\n        Google Cloud Storage bucket name for exports.\n    reducers : set[str] or None, optional\n        Set of reducer names to apply, by default None.\n    original_index_column_name : str, optional\n        Name of the column to store original indices, by default \"original_index\".\n    start_date_column_name : str, optional\n        Name of the start date column, by default \"start_date\".\n    end_date_column_name : str, optional\n        Name of the end date column, by default \"end_date\".\n    subsampling_max_pixels : float, optional\n        Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.\n    cluster_size : int, optional\n        Maximum cluster size for spatial grouping, by default 500.\n    force_redownload : bool, optional\n        Whether to force re-download of existing data, by default False.\n    wait : bool, optional\n        Whether to wait for task completion, by default True.\n\n    Returns\n    -------\n    None or pd.DataFrame\n        If wait is True, returns DataFrame with combined results.\n        If wait is False, returns None.\n    \"\"\"\n    from smart_open import open  # noqa: A004\n\n    if len(gdf) == 0:\n        logging.warning(\"Empty GeoDataFrame, nothing to download\")\n        return None\n\n    def download_multiple_sits_task_gcs(\n        gdf: gpd.GeoDataFrame,\n        satellite: AbstractSatellite,\n        bucket_name: str,\n        file_path: str,\n        reducers: set[str] | None = None,\n        original_index_column_name: str = \"original_index\",\n        start_date_column_name: str = \"start_date\",\n        end_date_column_name: str = \"end_date\",\n        subsampling_max_pixels: float = 1_000,\n        taskname: str = \"\",\n    ) -&gt; ee.batch.Task:\n        \"\"\"\n        Create a Google Earth Engine export task to Google Cloud Storage.\n\n        Parameters\n        ----------\n        gdf : gpd.GeoDataFrame\n            GeoDataFrame containing geometries and temporal information.\n        satellite : AbstractSatellite\n            Satellite configuration object.\n        bucket_name : str\n            Google Cloud Storage bucket name.\n        file_path : str\n            File path within the bucket for the exported file.\n        reducers : set[str] or None, optional\n            Set of reducer names to apply, by default None.\n        original_index_column_name : str, optional\n            Name of the column to store original indices, by default \"original_index\".\n        start_date_column_name : str, optional\n            Name of the start date column, by default \"start_date\".\n        end_date_column_name : str, optional\n            Name of the end date column, by default \"end_date\".\n        subsampling_max_pixels : float, optional\n            Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.\n        taskname : str, optional\n            Custom task name, by default \"\".\n\n        Returns\n        -------\n        ee.batch.Task\n            Earth Engine export task object.\n        \"\"\"\n        if taskname == \"\":\n            taskname = file_path\n\n        ee_expression = build_ee_expression(\n            gdf,\n            satellite,\n            reducers,\n            subsampling_max_pixels,\n            original_index_column_name,\n            start_date_column_name,\n            end_date_column_name,\n        )\n\n        task = ee.batch.Export.table.toCloudStorage(\n            bucket=bucket_name,\n            collection=ee_expression,\n            description=taskname,\n            fileFormat=\"CSV\",\n            fileNamePrefix=file_path,\n            selectors=build_selectors(satellite, reducers),\n        )\n\n        return task\n\n    gdf = sanitize_and_prepare_input_gdf(\n        gdf, satellite, original_index_column_name, cluster_size, start_date_column_name, end_date_column_name\n    )\n\n    task_mgr = GEETaskManager()\n    tasks_df = ee_get_tasks_status()\n    tasks_df = tasks_df[tasks_df.description.str.startswith(\"agl_\")].reset_index(drop=True)\n    completed_or_running_tasks = set(\n        tasks_df.description.apply(lambda x: x.split(\"_\", 1)[0] + \"_\" + x.split(\"_\", 2)[2]).tolist()\n    )  # The task is the same, no matter who started it\n\n    username = getpass.getuser().replace(\"_\", \"\")\n    hashname = create_gdf_hash(gdf, start_date_column_name, end_date_column_name)\n\n    gcs_save_folder = f\"agl/{satellite.shortName}_{hashname}\"\n    metadata_dict: dict[str, str] = {}\n    metadata_dict |= log_dict_function_call_summary([\"gdf\", \"satellite\"])\n    metadata_dict |= satellite.log_dict()\n    metadata_dict[\"user\"] = username\n    metadata_dict[\"creation_date\"] = pd.Timestamp.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    with open(f\"gs://{bucket_name}/{gcs_save_folder}/metadata.json\", \"w\") as f:\n        json.dump(metadata_dict, f, indent=4)\n\n    with open(f\"gs://{bucket_name}/{gcs_save_folder}/geodataframe.parquet\", \"wb\") as f:\n        gdf.to_parquet(f, compression=\"brotli\")\n\n    file_uris = []\n\n    for cluster_id in tqdm(sorted(gdf.cluster_id.unique())):\n        cluster_id = int(cluster_id)\n\n        if (force_redownload) or (\n            f\"agl_multiple_sits_{satellite.shortName}_{hashname}_{cluster_id}\" not in completed_or_running_tasks\n        ):\n            # TODO: Also skip if the file already exists in GCS\n            task = download_multiple_sits_task_gcs(\n                gdf[gdf.cluster_id == cluster_id],\n                satellite,\n                bucket_name=bucket_name,\n                file_path=f\"{gcs_save_folder}/{cluster_id}\",\n                reducers=reducers,\n                original_index_column_name=original_index_column_name,\n                start_date_column_name=start_date_column_name,\n                end_date_column_name=end_date_column_name,\n                subsampling_max_pixels=subsampling_max_pixels,\n                taskname=f\"agl_{username}_multiple_sits_{satellite.shortName}_{hashname}_{cluster_id}\",\n            )\n\n            task_mgr.add(task)\n\n        file_uris.append(f\"gs://{bucket_name}/{gcs_save_folder}/{cluster_id}.csv\")\n\n    task_mgr.start()\n\n    if wait:\n        task_mgr.wait()\n\n        df = pd.DataFrame()\n        for file_uri in file_uris:\n            with open(file_uri, \"r\") as f:\n                sub_df = pd.read_csv(f)\n                df = pd.concat([df, sub_df], ignore_index=True)\n\n        df = prepare_output_df(df, satellite, original_index_column_name)\n        return df\n    else:\n        return None\n</code></pre>"},{"location":"modules/#agrigee_lite.get.multiple_sits_gdrive","title":"<code>multiple_sits_gdrive(gdf, satellite, reducers=None, original_index_column_name='original_index', start_date_column_name='start_date', end_date_column_name='end_date', subsampling_max_pixels=1000, cluster_size=500, gee_save_folder='AGL_EXPORTS', force_redownload=False, wait=True)</code>","text":"<p>Download satellite time series using Google Earth Engine tasks to Google Drive.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing geometries and temporal information.</p> required <code>satellite</code> <code>AbstractSatellite</code> <p>Satellite configuration object.</p> required <code>reducers</code> <code>set[str] or None</code> <p>Set of reducer names to apply, by default None.</p> <code>None</code> <code>original_index_column_name</code> <code>str</code> <p>Name of the column to store original indices, by default \"original_index\".</p> <code>'original_index'</code> <code>start_date_column_name</code> <code>str</code> <p>Name of the start date column, by default \"start_date\".</p> <code>'start_date'</code> <code>end_date_column_name</code> <code>str</code> <p>Name of the end date column, by default \"end_date\".</p> <code>'end_date'</code> <code>subsampling_max_pixels</code> <code>float</code> <p>Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.</p> <code>1000</code> <code>cluster_size</code> <code>int</code> <p>Maximum cluster size for spatial grouping, by default 500.</p> <code>500</code> <code>gee_save_folder</code> <code>str</code> <p>Google Drive folder name for saving exports, by default \"AGL_EXPORTS\".</p> <code>'AGL_EXPORTS'</code> <code>force_redownload</code> <code>bool</code> <p>Whether to force re-download of existing data, by default False.</p> <code>False</code> <code>wait</code> <code>bool</code> <p>Whether to wait for task completion, by default True.</p> <code>True</code> Source code in <code>agrigee_lite/get/sits.py</code> <pre><code>def download_multiple_sits_chunks_gdrive(\n    gdf: gpd.GeoDataFrame,\n    satellite: AbstractSatellite,\n    reducers: set[str] | None = None,\n    original_index_column_name: str = \"original_index\",\n    start_date_column_name: str = \"start_date\",\n    end_date_column_name: str = \"end_date\",\n    subsampling_max_pixels: float = 1_000,\n    cluster_size: int = 500,\n    gee_save_folder: str = \"AGL_EXPORTS\",\n    force_redownload: bool = False,\n    wait: bool = True,\n) -&gt; None:\n    \"\"\"\n    Download satellite time series using Google Earth Engine tasks to Google Drive.\n\n    Parameters\n    ----------\n    gdf : gpd.GeoDataFrame\n        GeoDataFrame containing geometries and temporal information.\n    satellite : AbstractSatellite\n        Satellite configuration object.\n    reducers : set[str] or None, optional\n        Set of reducer names to apply, by default None.\n    original_index_column_name : str, optional\n        Name of the column to store original indices, by default \"original_index\".\n    start_date_column_name : str, optional\n        Name of the start date column, by default \"start_date\".\n    end_date_column_name : str, optional\n        Name of the end date column, by default \"end_date\".\n    subsampling_max_pixels : float, optional\n        Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.\n    cluster_size : int, optional\n        Maximum cluster size for spatial grouping, by default 500.\n    gee_save_folder : str, optional\n        Google Drive folder name for saving exports, by default \"AGL_EXPORTS\".\n    force_redownload : bool, optional\n        Whether to force re-download of existing data, by default False.\n    wait : bool, optional\n        Whether to wait for task completion, by default True.\n    \"\"\"\n    if len(gdf) == 0:\n        return None\n\n    def download_multiple_sits_task_gdrive(\n        gdf: gpd.GeoDataFrame,\n        satellite: AbstractSatellite,\n        file_stem: str,\n        reducers: set[str] | None = None,\n        original_index_column_name: str = \"original_index\",\n        start_date_column_name: str = \"start_date\",\n        end_date_column_name: str = \"end_date\",\n        subsampling_max_pixels: float = 1_000,\n        taskname: str = \"\",\n        gee_save_folder: str = \"AGL_EXPORTS\",\n    ) -&gt; ee.batch.Task:\n        \"\"\"\n        Create a Google Earth Engine export task to Google Drive.\n\n        Parameters\n        ----------\n        gdf : gpd.GeoDataFrame\n            GeoDataFrame containing geometries and temporal information.\n        satellite : AbstractSatellite\n            Satellite configuration object.\n        file_stem : str\n            Base filename for the exported file.\n        reducers : set[str] or None, optional\n            Set of reducer names to apply, by default None.\n        original_index_column_name : str, optional\n            Name of the column to store original indices, by default \"original_index\".\n        start_date_column_name : str, optional\n            Name of the start date column, by default \"start_date\".\n        end_date_column_name : str, optional\n            Name of the end date column, by default \"end_date\".\n        subsampling_max_pixels : float, optional\n            Maximum pixels for sampling: &gt;1 = absolute count, \u22641 = fraction of area (e.g., 0.5 = 50% sampling), by default 1_000.\n        taskname : str, optional\n            Custom task name, by default \"\".\n        gee_save_folder : str, optional\n            Google Drive folder name, by default \"AGL_EXPORTS\".\n\n        Returns\n        -------\n        ee.batch.Task\n            Earth Engine export task object.\n        \"\"\"\n        if taskname == \"\":\n            taskname = file_stem\n\n        ee_expression = build_ee_expression(\n            gdf,\n            satellite,\n            reducers,\n            subsampling_max_pixels,\n            original_index_column_name,\n            start_date_column_name,\n            end_date_column_name,\n        )\n\n        task = ee.batch.Export.table.toDrive(\n            collection=ee_expression,\n            description=taskname,\n            fileFormat=\"CSV\",\n            fileNamePrefix=file_stem,\n            folder=gee_save_folder,\n            selectors=build_selectors(satellite, reducers),\n        )\n\n        return task\n\n    gdf = sanitize_and_prepare_input_gdf(\n        gdf, satellite, original_index_column_name, cluster_size, start_date_column_name, end_date_column_name\n    )\n\n    task_mgr = GEETaskManager()\n\n    tasks_df = ee_get_tasks_status()\n    tasks_df = tasks_df[tasks_df.description.str.startswith(\"agl_multiple_sits_\")]\n    completed_or_running_tasks = set(\n        tasks_df.description.apply(lambda x: x.split(\"_\", 1)[0] + \"_\" + x.split(\"_\", 2)[2]).tolist()\n    )  # The task is the same, no matter who started it\n\n    username = getpass.getuser().replace(\"_\", \"\")\n    hashname = create_gdf_hash(gdf, start_date_column_name, end_date_column_name)\n\n    for cluster_id in tqdm(\n        sorted(gdf.cluster_id.unique()), desc=f\"Creating GEE tasks ({satellite.shortName}_{hashname}_{cluster_size})\"\n    ):\n        cluster_id = int(cluster_id)\n\n        if (force_redownload) or (\n            f\"agl_multiple_sits_{satellite.shortName}_{hashname}_{cluster_id}\" not in completed_or_running_tasks\n        ):\n            task = download_multiple_sits_task_gdrive(\n                gdf[gdf.cluster_id == cluster_id],\n                satellite,\n                f\"{satellite.shortName}_{hashname}_{cluster_id}\",\n                reducers=reducers,\n                original_index_column_name=original_index_column_name,\n                start_date_column_name=start_date_column_name,\n                end_date_column_name=end_date_column_name,\n                subsampling_max_pixels=subsampling_max_pixels,\n                taskname=f\"agl_{username}_sits_{satellite.shortName}_{hashname}_{cluster_id}\",\n                gee_save_folder=gee_save_folder,\n            )\n\n            task_mgr.add(task)\n\n    task_mgr.start()  # Start all tasks at once allows user to cancel them before submitted to GEE\n\n    if wait:\n        task_mgr.wait()\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.ANADEM","title":"<code>ANADEM</code>","text":"<p>               Bases: <code>SingleImageSatellite</code></p> <p>Satellite abstraction for ANADEM (Altimetric and Topographic Attributes of the Brazilian Territory).</p> <p>ANADEM is a DEM-derived (Digital Elevation Model) product designed to support land analysis based on elevation, slope, and aspect characteristics across the Brazilian territory. It is particularly useful for ecological zoning, terrain classification, hydrological modeling, and environmental risk assessment.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>list of str</code> <p>List of bands to select. Defaults to ['elevation', 'slope', 'aspect']. - 'elevation': Ground elevation in meters. - 'slope': Degree of inclination derived from elevation. - 'aspect': Direction of slope (0-360\u00b0), where 0 = North.</p> <code>None</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border to reduce edge artifacts.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>50_000</code> Satellite Information <p>+------------------------------------+-----------------------------+ | Field                              | Value                       | +------------------------------------+-----------------------------+ | Name                               | ANADEM                      | | Resolution                         | 30 meters                   | | Source                             | FURGS, ANA                  | | Coverage                           | Brazil                      | | Derived From                       | SRTM + auxiliary DEMs       | +------------------------------------+-----------------------------+</p> Band Information <p>+-----------+----------------------------+---------------------------+ | Band Name | Description                | Unit / Range              | +-----------+----------------------------+---------------------------+ | elevation | Ground elevation           | meters above sea level    | | slope     | Terrain slope              | degrees (0\u00b0-90\u00b0)          | | aspect    | Orientation of slope       | degrees (0\u00b0-360\u00b0 from N)  | +-----------+----------------------------+---------------------------+</p> Notes <ul> <li>The slope and aspect bands are computed from the elevation layer using the <code>ee.Terrain.products()</code> utility.</li> <li>The <code>compute()</code> method calculates:<ul> <li>Mean elevation over the region.</li> <li>Percentage breakdown of slope classes:<ul> <li>Flat (0-3\u00b0), Gentle (3-8\u00b0), Undulating (8-20\u00b0), Strong (20-45\u00b0), Mountainous (45-75\u00b0), and Steep (&gt;75\u00b0).</li> </ul> </li> <li>Percentage breakdown of aspect classes:<ul> <li>North, NE, East, SE, South, SW, West, NW.</li> </ul> </li> </ul> </li> <li>These statistics are returned as a <code>FeatureCollection</code> with a single feature containing the computed values.</li> <li>Reference paper: https://www.mdpi.com/2072-4292/16/13/2321</li> <li>Data source: https://hge-iph.github.io/anadem/</li> </ul> Source code in <code>agrigee_lite/sat/dem.py</code> <pre><code>class ANADEM(SingleImageSatellite):\n    \"\"\"\n    Satellite abstraction for ANADEM (Altimetric and Topographic Attributes of the Brazilian Territory).\n\n    ANADEM is a DEM-derived (Digital Elevation Model) product designed to support land analysis\n    based on elevation, slope, and aspect characteristics across the Brazilian territory.\n    It is particularly useful for ecological zoning, terrain classification, hydrological modeling,\n    and environmental risk assessment.\n\n    Parameters\n    ----------\n    bands : list of str, optional\n        List of bands to select. Defaults to ['elevation', 'slope', 'aspect'].\n        - 'elevation': Ground elevation in meters.\n        - 'slope': Degree of inclination derived from elevation.\n        - 'aspect': Direction of slope (0-360\u00b0), where 0 = North.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border to reduce edge artifacts.\n    min_area_to_keep_border : int, default=50_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Satellite Information\n    ---------------------\n    +------------------------------------+-----------------------------+\n    | Field                              | Value                       |\n    +------------------------------------+-----------------------------+\n    | Name                               | ANADEM                      |\n    | Resolution                         | 30 meters                   |\n    | Source                             | FURGS, ANA                  |\n    | Coverage                           | Brazil                      |\n    | Derived From                       | SRTM + auxiliary DEMs       |\n    +------------------------------------+-----------------------------+\n\n    Band Information\n    ----------------\n    +-----------+----------------------------+---------------------------+\n    | Band Name | Description                | Unit / Range              |\n    +-----------+----------------------------+---------------------------+\n    | elevation | Ground elevation           | meters above sea level    |\n    | slope     | Terrain slope              | degrees (0\u00b0-90\u00b0)          |\n    | aspect    | Orientation of slope       | degrees (0\u00b0-360\u00b0 from N)  |\n    +-----------+----------------------------+---------------------------+\n\n    Notes\n    -----\n    - The slope and aspect bands are computed from the elevation layer using the\n    `ee.Terrain.products()` utility.\n    - The `compute()` method calculates:\n        - Mean elevation over the region.\n        - Percentage breakdown of slope classes:\n            - Flat (0-3\u00b0), Gentle (3-8\u00b0), Undulating (8-20\u00b0),\n            Strong (20-45\u00b0), Mountainous (45-75\u00b0), and Steep (&gt;75\u00b0).\n        - Percentage breakdown of aspect classes:\n            - North, NE, East, SE, South, SW, West, NW.\n    - These statistics are returned as a `FeatureCollection` with a single feature\n    containing the computed values.\n    - Reference paper: https://www.mdpi.com/2072-4292/16/13/2321\n    - Data source: https://hge-iph.github.io/anadem/\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: list[str] | None = None,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 50_000,\n    ):\n        if bands is None:\n            bands = [\"elevation\", \"slope\", \"aspect\"]\n\n        super().__init__()\n\n        self.imageName: str = \"projects/et-brasil/assets/anadem/v1\"\n        self.pixelSize: int = 30\n        self.shortName: str = \"anadem\"\n\n        self.selectedBands: list[tuple[str, str]] = [(band, f\"{band}\") for band in bands]\n\n        self.startDate = \"1900-01-01\"\n        self.endDate = \"2050-01-01\"\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n\n        self.toDownloadSelectors = self._build_to_download_selectors()\n\n    def _build_to_download_selectors(self) -&gt; list[str]:\n        selectors = []\n\n        band_aliases = [alias for _, alias in self.selectedBands]\n\n        if \"elevation\" in band_aliases:\n            selectors += [\"40_elevation_mean\"]\n\n        if \"slope\" in band_aliases:\n            selectors += [\n                \"41_slope_flat\",\n                \"42_slope_gentle\",\n                \"43_slope_undulating\",\n                \"44_slope_strong\",\n                \"45_slope_mountainous\",\n                \"46_slope_steep\",\n            ]\n\n        if \"aspect\" in band_aliases:\n            selectors += [\n                \"47_cardinal_n\",\n                \"48_cardinal_ne\",\n                \"49_cardinal_e\",\n                \"50_cardinal_se\",\n                \"51_cardinal_s\",\n                \"52_cardinal_sw\",\n                \"53_cardinal_w\",\n                \"54_cardinal_nw\",\n            ]\n\n        return selectors\n\n    def image(self, ee_feature: ee.Feature) -&gt; ee.Image:\n        image = ee.Image(self.imageName).updateMask(ee.Image(self.imageName).neq(-9999))\n\n        requested_bands = [b for b, _ in self.selectedBands]\n\n        if any(b in requested_bands for b in [\"slope\", \"aspect\"]):\n            terrain = ee.Terrain.products(image)\n            image = image.addBands(terrain.select([\"slope\", \"aspect\"]))\n\n        selected_band_names = [b for b, _ in self.selectedBands]\n        renamed_band_names = [alias for _, alias in self.selectedBands]\n\n        return image.select(selected_band_names, renamed_band_names)\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        ee_img = self.image(ee_feature)\n        ee_img = ee_map_valid_pixels(ee_img, ee_geometry, self.pixelSize)\n\n        selected_band_names = [alias for _, alias in self.selectedBands]\n\n        stats_dict = {\n            \"00_indexnum\": ee_feature.get(\"0\"),\n        }\n\n        # --- Elevation mean ---\n        if \"elevation\" in selected_band_names:\n            elevation_mean = (\n                ee_img.select(\"elevation\")\n                .reduceRegion(\n                    reducer=ee.Reducer.mean(),\n                    geometry=ee_geometry,\n                    scale=self.pixelSize,\n                    maxPixels=subsampling_max_pixels,\n                    bestEffort=True,\n                )\n                .get(\"elevation\")\n            )\n            stats_dict[\"40_elevation_mean\"] = elevation_mean\n\n        # --- Slope class breakdown ---\n        if \"slope\" in selected_band_names:\n            slope = ee_img.select(\"slope\")\n\n            slope_classes = {\n                \"41_slope_flat\": slope.gte(0).And(slope.lt(3)),\n                \"42_slope_gentle\": slope.gte(3).And(slope.lt(8)),\n                \"43_slope_undulating\": slope.gte(8).And(slope.lt(20)),\n                \"44_slope_strong\": slope.gte(20).And(slope.lt(45)),\n                \"45_slope_mountainous\": slope.gte(45).And(slope.lte(75)),\n                \"46_slope_steep\": slope.gt(75),\n            }\n\n            valid_mask = ee_img.select(\"slope\").mask()\n            total_pixels = (\n                ee.Image(1)\n                .updateMask(valid_mask)\n                .reduceRegion(\n                    reducer=ee.Reducer.count(),\n                    geometry=ee_geometry,\n                    scale=self.pixelSize,\n                    maxPixels=subsampling_max_pixels,\n                    bestEffort=True,\n                )\n                .getNumber(\"constant\")\n            )\n\n            for class_name, mask in slope_classes.items():\n                count = (\n                    ee.Image(1)\n                    .updateMask(mask)\n                    .reduceRegion(\n                        reducer=ee.Reducer.count(),\n                        geometry=ee_geometry,\n                        scale=self.pixelSize,\n                        maxPixels=subsampling_max_pixels,\n                        bestEffort=True,\n                    )\n                    .getNumber(\"constant\")\n                )\n                percent = count.divide(total_pixels)\n                stats_dict[class_name] = percent\n\n        # --- Aspect class breakdown ---\n        if \"aspect\" in selected_band_names:\n            aspect = ee_img.select(\"aspect\")\n\n            aspect_classes = {\n                \"47_cardinal_n\": aspect.gte(337.5).Or(aspect.lt(22.5)),\n                \"48_cardinal_ne\": aspect.gte(22.5).And(aspect.lt(67.5)),\n                \"49_cardinal_e\": aspect.gte(67.5).And(aspect.lt(112.5)),\n                \"50_cardinal_se\": aspect.gte(112.5).And(aspect.lt(157.5)),\n                \"51_cardinal_s\": aspect.gte(157.5).And(aspect.lt(202.5)),\n                \"52_cardinal_sw\": aspect.gte(202.5).And(aspect.lt(247.5)),\n                \"53_cardinal_w\": aspect.gte(247.5).And(aspect.lt(292.5)),\n                \"54_cardinal_nw\": aspect.gte(292.5).And(aspect.lt(337.5)),\n            }\n\n            valid_aspect = aspect.mask()\n            total_aspect_pixels = (\n                ee.Image(1)\n                .updateMask(valid_aspect)\n                .reduceRegion(\n                    reducer=ee.Reducer.count(),\n                    geometry=ee_geometry,\n                    scale=self.pixelSize,\n                    maxPixels=subsampling_max_pixels,\n                    bestEffort=True,\n                )\n                .getNumber(\"constant\")\n            )\n\n            for class_name, mask in aspect_classes.items():\n                count = (\n                    ee.Image(1)\n                    .updateMask(mask)\n                    .reduceRegion(\n                        reducer=ee.Reducer.count(),\n                        geometry=ee_geometry,\n                        scale=self.pixelSize,\n                        maxPixels=subsampling_max_pixels,\n                        bestEffort=True,\n                    )\n                    .getNumber(\"constant\")\n                )\n                percent = count.divide(total_aspect_pixels)\n                stats_dict[class_name] = percent\n\n        # --- ValidPixelCount ---\n        valid_pixel_count = (\n            ee_img.select(selected_band_names[0])\n            .mask()\n            .reduceRegion(\n                reducer=ee.Reducer.count(),\n                geometry=ee_geometry,\n                scale=self.pixelSize,\n                maxPixels=subsampling_max_pixels,\n                bestEffort=True,\n            )\n            .getNumber(selected_band_names[0])\n        )\n        stats_dict[\"99_validPixelsCount\"] = valid_pixel_count\n\n        stats_feature = ee.Feature(None, stats_dict)\n        return ee.FeatureCollection([stats_feature])\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Landsat5","title":"<code>Landsat5</code>","text":"<p>               Bases: <code>AbstractLandsat</code></p> <p>Satellite abstraction for Landsat 5 (TM sensor, Collection 2).</p> <p>Landsat 5 was launched in 1984 and provided more than 29 years of Earth observation data. This class supports both TOA and SR products, with optional cloud masking using the QA_PIXEL band.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>set of str</code> <p>Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].</p> <code>None</code> <code>indices</code> <code>set of str</code> <p>Spectral indices to compute from the selected bands.</p> <code>None</code> <code>use_sr</code> <code>bool</code> <p>Whether to use surface reflectance products ('SR_B' bands). If False, uses top-of-atmosphere reflectance ('B' bands).</p> <code>True</code> <code>tier</code> <code>int</code> <p>Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.</p> <code>1</code> <code>use_cloud_mask</code> <code>bool</code> <p>Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>12</code> <code>toa_cloud_filter_strength</code> <code>int</code> <p>Strength of the additional cloud filter applied to TOA imagery (if use_sr=False). Used in the <code>remove_l_toa_tough_clouds</code> step.</p> <code>15</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>50_000</code> Cloud Masking <p>Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS: - Applied to both TOA and SR products when <code>use_cloud_mask=True</code> - For TOA collections, an additional filter (<code>remove_l_toa_tough_clouds</code>) is applied to remove low-quality observations based on a simple cloud scoring method.</p> Satellite Information <p>+----------------------------+------------------------+ | Field                      | Value                  | +----------------------------+------------------------+ | Name                       | Landsat 5 TM           | | Sensor                     | TM (Thematic Mapper)   | | Platform                   | Landsat 5              | | Temporal Resolution        | 16 days                | | Pixel Size                 | 30 meters              | | Coverage                   | Global                 | +----------------------------+------------------------+</p> Collection Dates <p>+-------------+------------+------------+ | Product     | Start Date | End Date  | +-------------+------------+------------+ | TOA         | 1984-03-01 | 2013-05-05 | | SR          | 1984-03-01 | 2012-05-05 | +-------------+------------+------------+</p> Band Information <p>+-----------+----------+-----------+------------------------+ | Band Name | TOA Name | SR Name   | Spectral Wavelength    | +-----------+----------+-----------+------------------------+ | blue      | B1       | SR_B1     | 450-520 nm             | | green     | B2       | SR_B2     | 520-600 nm             | | red       | B3       | SR_B3     | 630-690 nm             | | nir       | B4       | SR_B4     | 770-900 nm             | | swir1     | B5       | SR_B5     | 1550-1750 nm           | | swir2     | B7       | SR_B7     | 2090-2350 nm           | +-----------+----------+-----------+------------------------+</p> Notes <ul> <li> <p>Landsat 5 TOA Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T1_TOA</p> </li> <li> <p>Landsat 5 TOA Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T2_TOA</p> </li> <li> <p>Landsat 5 SR Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T1_L2</p> </li> <li> <p>Landsat 5 SR Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T2_L2</p> </li> <li> <p>Cloud mask reference (QA_PIXEL flags):     https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment</p> </li> <li> <p>TOA cloud filtering (Simple Cloud Score):     https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score</p> </li> </ul> Source code in <code>agrigee_lite/sat/landsat.py</code> <pre><code>class Landsat5(AbstractLandsat):\n    \"\"\"\n    Satellite abstraction for Landsat 5 (TM sensor, Collection 2).\n\n    Landsat 5 was launched in 1984 and provided more than 29 years of Earth observation data.\n    This class supports both TOA and SR products, with optional cloud masking using the QA_PIXEL band.\n\n    Parameters\n    ----------\n    bands : set of str, optional\n        Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].\n    indices : set of str, optional\n        Spectral indices to compute from the selected bands.\n    use_sr : bool, default=True\n        Whether to use surface reflectance products ('SR_B*' bands).\n        If False, uses top-of-atmosphere reflectance ('B*' bands).\n    tier : int, default=1\n        Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.\n    use_cloud_mask : bool, default=True\n        Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.\n    min_valid_pixel_count : int, default=12\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    toa_cloud_filter_strength : int, default=15\n        Strength of the additional cloud filter applied to TOA imagery (if use_sr=False).\n        Used in the `remove_l_toa_tough_clouds` step.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=50_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Cloud Masking\n    -------------\n    Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS:\n    - Applied to both TOA and SR products when `use_cloud_mask=True`\n    - For TOA collections, an additional filter (`remove_l_toa_tough_clouds`) is applied\n    to remove low-quality observations based on a simple cloud scoring method.\n\n    Satellite Information\n    ---------------------\n    +----------------------------+------------------------+\n    | Field                      | Value                  |\n    +----------------------------+------------------------+\n    | Name                       | Landsat 5 TM           |\n    | Sensor                     | TM (Thematic Mapper)   |\n    | Platform                   | Landsat 5              |\n    | Temporal Resolution        | 16 days                |\n    | Pixel Size                 | 30 meters              |\n    | Coverage                   | Global                 |\n    +----------------------------+------------------------+\n\n    Collection Dates\n    ----------------\n    +-------------+------------+------------+\n    | Product     | Start Date | End Date  |\n    +-------------+------------+------------+\n    | TOA         | 1984-03-01 | 2013-05-05 |\n    | SR          | 1984-03-01 | 2012-05-05 |\n    +-------------+------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+----------+-----------+------------------------+\n    | Band Name | TOA Name | SR Name   | Spectral Wavelength    |\n    +-----------+----------+-----------+------------------------+\n    | blue      | B1       | SR_B1     | 450-520 nm             |\n    | green     | B2       | SR_B2     | 520-600 nm             |\n    | red       | B3       | SR_B3     | 630-690 nm             |\n    | nir       | B4       | SR_B4     | 770-900 nm             |\n    | swir1     | B5       | SR_B5     | 1550-1750 nm           |\n    | swir2     | B7       | SR_B7     | 2090-2350 nm           |\n    +-----------+----------+-----------+------------------------+\n\n    Notes\n    -----\n    - Landsat 5 TOA Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T1_TOA\n\n    - Landsat 5 TOA Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T2_TOA\n\n    - Landsat 5 SR Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T1_L2\n\n    - Landsat 5 SR Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LT05_C02_T2_L2\n\n    - Cloud mask reference (QA_PIXEL flags):\n        https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment\n\n    - TOA cloud filtering (Simple Cloud Score):\n        https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        use_sr: bool = True,\n        tier: int = 1,\n        use_cloud_mask: bool = True,\n        min_valid_pixel_count: int = 12,\n        toa_cloud_filter_strength: int = 15,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 50_000,\n    ):\n        toa = {\"blue\": \"B1\", \"green\": \"B2\", \"red\": \"B3\", \"nir\": \"B4\", \"swir1\": \"B5\", \"swir2\": \"B7\"}\n        sr = {\n            \"blue\": \"SR_B1\",\n            \"green\": \"SR_B2\",\n            \"red\": \"SR_B3\",\n            \"nir\": \"SR_B4\",\n            \"swir1\": \"SR_B5\",\n            \"swir2\": \"SR_B7\",\n        }\n        super().__init__(\n            indices=indices,\n            sensor_code=\"LT05\",\n            toa_band_map=toa,\n            sr_band_map=sr,\n            short_base=\"l5\",\n            start_date=\"1984-03-01\",\n            end_date=\"2013-05-05\",\n            bands=bands,\n            use_sr=use_sr,\n            tier=tier,\n            use_cloud_mask=use_cloud_mask,\n            min_valid_pixel_count=min_valid_pixel_count,\n            toa_cloud_filter_strength=toa_cloud_filter_strength,\n            border_pixels_to_erode=border_pixels_to_erode,\n            min_area_to_keep_border=min_area_to_keep_border,\n            use_pan_sharpening=False,\n        )\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Landsat7","title":"<code>Landsat7</code>","text":"<p>               Bases: <code>AbstractLandsat</code></p> <p>Satellite abstraction for Landsat 7 (ETM+ sensor, Collection 2).</p> <p>Landsat 7 was launched in 1999 and provided over two decades of data. This class supports both TOA and SR products, with optional cloud masking using the QA_PIXEL band.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>set of str</code> <p>Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].</p> <code>None</code> <code>indices</code> <code>set of str</code> <p>Spectral indices to compute from the selected bands.</p> <code>None</code> <code>use_sr</code> <code>bool</code> <p>Whether to use surface reflectance products ('SR_B' bands). If False, uses top-of-atmosphere reflectance ('B' bands).</p> <code>True</code> <code>tier</code> <code>int</code> <p>Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.</p> <code>1</code> <code>use_cloud_mask</code> <code>bool</code> <p>Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>12</code> <code>toa_cloud_filter_strength</code> <code>int</code> <p>Strength of the additional cloud filter applied to TOA imagery (if use_sr=False). Used in the <code>remove_l_toa_tough_clouds</code> step.</p> <code>15</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>50_000</code> <code>use_pan_sharpening</code> <code>bool</code> <p>If True, applies pan sharpening to the RGB bands using the 15m-resolution panchromatic band (B8). Only applicable when <code>use_sr=False</code>. Raises ValueError if used with SR products.</p> <code>False</code> Cloud Masking <p>Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS: - Applied to both TOA and SR products when <code>use_cloud_mask=True</code> - For TOA collections, an additional filter (<code>remove_l_toa_tough_clouds</code>) is applied to remove low-quality observations based on a simple cloud scoring method.</p> Satellite Information <p>+----------------------------+------------------------+ | Field                      | Value                  | +----------------------------+------------------------+ | Name                       | Landsat 7 ETM+         | | Sensor                     | ETM+ (Enhanced TM Plus)| | Platform                   | Landsat 7              | | Temporal Resolution        | 16 days                | | Pixel Size                 | 30 meters              | | Coverage                   | Global                 | +----------------------------+------------------------+</p> Collection Dates <p>+-------------+------------+------------+ | Product     | Start Date | End Date  | +-------------+------------+------------+ | TOA         | 1999-04-15 | 2022-04-06 | | SR          | 1999-04-15 | 2022-04-06 | +-------------+------------+------------+</p> Band Information <p>+-----------+----------+-----------+------------------------+ | Band Name | TOA Name | SR Name   | Spectral Wavelength    | +-----------+----------+-----------+------------------------+ | blue      | B1       | SR_B1     | 450-520 nm             | | green     | B2       | SR_B2     | 520-600 nm             | | red       | B3       | SR_B3     | 630-690 nm             | | nir       | B4       | SR_B4     | 770-900 nm             | | swir1     | B5       | SR_B5     | 1550-1750 nm           | | swir2     | B7       | SR_B7     | 2090-2350 nm           | | pan       | B8       |    \u2014      | 520-900 nm (panchromatic) | +-----------+----------+-----------+------------------------+</p> Notes <ul> <li> <p>Landsat 7 TOA Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T1_TOA</p> </li> <li> <p>Landsat 7 TOA Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T2_TOA</p> </li> <li> <p>Landsat 7 SR Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T1_L2</p> </li> <li> <p>Landsat 7 SR Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T2_L2</p> </li> <li> <p>Cloud mask reference (QA_PIXEL flags):     https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment</p> </li> <li> <p>TOA cloud filtering (Simple Cloud Score):     https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score</p> </li> </ul> Source code in <code>agrigee_lite/sat/landsat.py</code> <pre><code>class Landsat7(AbstractLandsat):\n    \"\"\"\n    Satellite abstraction for Landsat 7 (ETM+ sensor, Collection 2).\n\n    Landsat 7 was launched in 1999 and provided over two decades of data.\n    This class supports both TOA and SR products, with optional cloud masking using the QA_PIXEL band.\n\n    Parameters\n    ----------\n    bands : set of str, optional\n        Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].\n    indices : set of str, optional\n        Spectral indices to compute from the selected bands.\n    use_sr : bool, default=True\n        Whether to use surface reflectance products ('SR_B*' bands).\n        If False, uses top-of-atmosphere reflectance ('B*' bands).\n    tier : int, default=1\n        Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.\n    use_cloud_mask : bool, default=True\n        Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.\n    min_valid_pixel_count : int, default=12\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    toa_cloud_filter_strength : int, default=15\n        Strength of the additional cloud filter applied to TOA imagery (if use_sr=False).\n        Used in the `remove_l_toa_tough_clouds` step.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=50_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n    use_pan_sharpening : bool, default=False\n        If True, applies pan sharpening to the RGB bands using the 15m-resolution panchromatic band (B8).\n        Only applicable when `use_sr=False`. Raises ValueError if used with SR products.\n\n    Cloud Masking\n    -------------\n    Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS:\n    - Applied to both TOA and SR products when `use_cloud_mask=True`\n    - For TOA collections, an additional filter (`remove_l_toa_tough_clouds`) is applied\n    to remove low-quality observations based on a simple cloud scoring method.\n\n    Satellite Information\n    ---------------------\n    +----------------------------+------------------------+\n    | Field                      | Value                  |\n    +----------------------------+------------------------+\n    | Name                       | Landsat 7 ETM+         |\n    | Sensor                     | ETM+ (Enhanced TM Plus)|\n    | Platform                   | Landsat 7              |\n    | Temporal Resolution        | 16 days                |\n    | Pixel Size                 | 30 meters              |\n    | Coverage                   | Global                 |\n    +----------------------------+------------------------+\n\n    Collection Dates\n    ----------------\n    +-------------+------------+------------+\n    | Product     | Start Date | End Date  |\n    +-------------+------------+------------+\n    | TOA         | 1999-04-15 | 2022-04-06 |\n    | SR          | 1999-04-15 | 2022-04-06 |\n    +-------------+------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+----------+-----------+------------------------+\n    | Band Name | TOA Name | SR Name   | Spectral Wavelength    |\n    +-----------+----------+-----------+------------------------+\n    | blue      | B1       | SR_B1     | 450-520 nm             |\n    | green     | B2       | SR_B2     | 520-600 nm             |\n    | red       | B3       | SR_B3     | 630-690 nm             |\n    | nir       | B4       | SR_B4     | 770-900 nm             |\n    | swir1     | B5       | SR_B5     | 1550-1750 nm           |\n    | swir2     | B7       | SR_B7     | 2090-2350 nm           |\n    | pan       | B8       |    \u2014      | 520-900 nm (panchromatic) |\n    +-----------+----------+-----------+------------------------+\n\n    Notes\n    -----\n    - Landsat 7 TOA Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T1_TOA\n\n    - Landsat 7 TOA Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T2_TOA\n\n    - Landsat 7 SR Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T1_L2\n\n    - Landsat 7 SR Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LE07_C02_T2_L2\n\n    - Cloud mask reference (QA_PIXEL flags):\n        https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment\n\n    - TOA cloud filtering (Simple Cloud Score):\n        https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        use_sr: bool = True,\n        tier: int = 1,\n        use_cloud_mask: bool = True,\n        min_valid_pixel_count: int = 12,\n        toa_cloud_filter_strength: int = 15,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 50_000,\n        use_pan_sharpening: bool = False,\n    ):\n        toa = {\"blue\": \"B1\", \"green\": \"B2\", \"red\": \"B3\", \"nir\": \"B4\", \"swir1\": \"B5\", \"swir2\": \"B7\", \"pan\": \"B8\"}\n        sr = {\n            \"blue\": \"SR_B1\",\n            \"green\": \"SR_B2\",\n            \"red\": \"SR_B3\",\n            \"nir\": \"SR_B4\",\n            \"swir1\": \"SR_B5\",\n            \"swir2\": \"SR_B7\",\n        }\n        super().__init__(\n            indices=indices,\n            sensor_code=\"LE07\",\n            toa_band_map=toa,\n            sr_band_map=sr,\n            short_base=\"l7\",\n            start_date=\"1999-04-15\",\n            end_date=\"2022-04-06\",\n            bands=bands,\n            use_sr=use_sr,\n            tier=tier,\n            use_cloud_mask=use_cloud_mask,\n            min_valid_pixel_count=min_valid_pixel_count,\n            toa_cloud_filter_strength=toa_cloud_filter_strength,\n            border_pixels_to_erode=border_pixels_to_erode,\n            min_area_to_keep_border=min_area_to_keep_border,\n            use_pan_sharpening=use_pan_sharpening,\n        )\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Landsat8","title":"<code>Landsat8</code>","text":"<p>               Bases: <code>AbstractLandsat</code></p> <p>Satellite abstraction for Landsat 8 (OLI/TIRS sensor, Collection 2).</p> <p>Landsat 8 was launched in 2013 and remains in operation, delivering high-quality Earth observation data. This class supports both TOA and SR products, with optional cloud masking using the QA_PIXEL band.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>set of str</code> <p>Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].</p> <code>None</code> <code>indices</code> <code>set of str</code> <p>Spectral indices to compute from the selected bands.</p> <code>None</code> <code>use_sr</code> <code>bool</code> <p>Whether to use surface reflectance products ('SR_B' bands). If False, uses top-of-atmosphere reflectance ('B' bands).</p> <code>True</code> <code>tier</code> <code>int</code> <p>Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.</p> <code>1</code> <code>use_cloud_mask</code> <code>bool</code> <p>Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>12</code> <code>toa_cloud_filter_strength</code> <code>int</code> <p>Strength of the additional cloud filter applied to TOA imagery (if use_sr=False). Used in the <code>remove_l_toa_tough_clouds</code> step.</p> <code>15</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>50_000</code> <code>use_pan_sharpening</code> <code>bool</code> <p>If True, applies pan sharpening to the RGB bands using the 15m-resolution panchromatic band (B8). Only applicable when <code>use_sr=False</code>. Raises ValueError if used with SR products.</p> <code>False</code> Cloud Masking <p>Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS: - Applied to both TOA and SR products when <code>use_cloud_mask=True</code> - For TOA collections, an additional filter (<code>remove_l_toa_tough_clouds</code>) is applied to remove low-quality observations based on a simple cloud scoring method.</p> Satellite Information <p>+----------------------------+------------------------+ | Field                      | Value                  | +----------------------------+------------------------+ | Name                       | Landsat 8 OLI/TIRS     | | Sensor                     | OLI + TIRS             | | Platform                   | Landsat 8              | | Temporal Resolution        | 16 days                | | Pixel Size                 | 30 meters              | | Coverage                   | Global                 | +----------------------------+------------------------+</p> Collection Dates <p>+-------------+------------+------------+ | Product     | Start Date | End Date  | +-------------+------------+------------+ | TOA         | 2013-04-11 | present   | | SR          | 2013-04-11 | present   | +-------------+------------+------------+</p> Band Information <p>+-----------+----------+-----------+------------------------+ | Band Name | TOA Name | SR Name   | Spectral Wavelength    | +-----------+----------+-----------+------------------------+ | blue      | B2       | SR_B2     | 450-515 nm             | | green     | B3       | SR_B3     | 525-600 nm             | | red       | B4       | SR_B4     | 630-680 nm             | | nir       | B5       | SR_B5     | 845-885 nm             | | swir1     | B6       | SR_B6     | 1560-1660 nm           | | swir2     | B7       | SR_B7     | 2100-2300 nm           | | pan       | B8       |    \u2014      | 520-900 nm (panchromatic) | +-----------+----------+-----------+------------------------+</p> Notes <ul> <li> <p>Landsat 8 TOA Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_TOA</p> </li> <li> <p>Landsat 8 TOA Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T2_TOA</p> </li> <li> <p>Landsat 8 SR Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_L2</p> </li> <li> <p>Landsat 8 SR Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T2_L2</p> </li> <li> <p>Cloud mask reference (QA_PIXEL flags):     https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment</p> </li> <li> <p>TOA cloud filtering (Simple Cloud Score):     https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score</p> </li> </ul> Source code in <code>agrigee_lite/sat/landsat.py</code> <pre><code>class Landsat8(AbstractLandsat):\n    \"\"\"\n    Satellite abstraction for Landsat 8 (OLI/TIRS sensor, Collection 2).\n\n    Landsat 8 was launched in 2013 and remains in operation, delivering high-quality Earth observation data.\n    This class supports both TOA and SR products, with optional cloud masking using the QA_PIXEL band.\n\n    Parameters\n    ----------\n    bands : set of str, optional\n        Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].\n    indices : set of str, optional\n        Spectral indices to compute from the selected bands.\n    use_sr : bool, default=True\n        Whether to use surface reflectance products ('SR_B*' bands).\n        If False, uses top-of-atmosphere reflectance ('B*' bands).\n    tier : int, default=1\n        Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.\n    use_cloud_mask : bool, default=True\n        Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.\n    min_valid_pixel_count : int, default=12\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    toa_cloud_filter_strength : int, default=15\n        Strength of the additional cloud filter applied to TOA imagery (if use_sr=False).\n        Used in the `remove_l_toa_tough_clouds` step.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=50_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n    use_pan_sharpening : bool, default=False\n        If True, applies pan sharpening to the RGB bands using the 15m-resolution panchromatic band (B8).\n        Only applicable when `use_sr=False`. Raises ValueError if used with SR products.\n\n    Cloud Masking\n    -------------\n    Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS:\n    - Applied to both TOA and SR products when `use_cloud_mask=True`\n    - For TOA collections, an additional filter (`remove_l_toa_tough_clouds`) is applied\n    to remove low-quality observations based on a simple cloud scoring method.\n\n    Satellite Information\n    ---------------------\n    +----------------------------+------------------------+\n    | Field                      | Value                  |\n    +----------------------------+------------------------+\n    | Name                       | Landsat 8 OLI/TIRS     |\n    | Sensor                     | OLI + TIRS             |\n    | Platform                   | Landsat 8              |\n    | Temporal Resolution        | 16 days                |\n    | Pixel Size                 | 30 meters              |\n    | Coverage                   | Global                 |\n    +----------------------------+------------------------+\n\n    Collection Dates\n    ----------------\n    +-------------+------------+------------+\n    | Product     | Start Date | End Date  |\n    +-------------+------------+------------+\n    | TOA         | 2013-04-11 | present   |\n    | SR          | 2013-04-11 | present   |\n    +-------------+------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+----------+-----------+------------------------+\n    | Band Name | TOA Name | SR Name   | Spectral Wavelength    |\n    +-----------+----------+-----------+------------------------+\n    | blue      | B2       | SR_B2     | 450-515 nm             |\n    | green     | B3       | SR_B3     | 525-600 nm             |\n    | red       | B4       | SR_B4     | 630-680 nm             |\n    | nir       | B5       | SR_B5     | 845-885 nm             |\n    | swir1     | B6       | SR_B6     | 1560-1660 nm           |\n    | swir2     | B7       | SR_B7     | 2100-2300 nm           |\n    | pan       | B8       |    \u2014      | 520-900 nm (panchromatic) |\n    +-----------+----------+-----------+------------------------+\n\n    Notes\n    -----\n    - Landsat 8 TOA Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_TOA\n\n    - Landsat 8 TOA Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T2_TOA\n\n    - Landsat 8 SR Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T1_L2\n\n    - Landsat 8 SR Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC08_C02_T2_L2\n\n    - Cloud mask reference (QA_PIXEL flags):\n        https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment\n\n    - TOA cloud filtering (Simple Cloud Score):\n        https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        use_sr: bool = True,\n        tier: int = 1,\n        use_cloud_mask: bool = True,\n        min_valid_pixel_count: int = 12,\n        toa_cloud_filter_strength: int = 15,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 50_000,\n        use_pan_sharpening: bool = False,\n    ):\n        toa = {\"blue\": \"B2\", \"green\": \"B3\", \"red\": \"B4\", \"nir\": \"B5\", \"swir1\": \"B6\", \"swir2\": \"B7\", \"pan\": \"B8\"}\n        sr = {\n            \"blue\": \"SR_B2\",\n            \"green\": \"SR_B3\",\n            \"red\": \"SR_B4\",\n            \"nir\": \"SR_B5\",\n            \"swir1\": \"SR_B6\",\n            \"swir2\": \"SR_B7\",\n        }\n        super().__init__(\n            indices=indices,\n            sensor_code=\"LC08\",\n            toa_band_map=toa,\n            sr_band_map=sr,\n            short_base=\"l8\",\n            start_date=\"2013-04-11\",\n            end_date=\"2050-01-01\",\n            bands=bands,\n            use_sr=use_sr,\n            tier=tier,\n            use_cloud_mask=use_cloud_mask,\n            min_valid_pixel_count=min_valid_pixel_count,\n            toa_cloud_filter_strength=toa_cloud_filter_strength,\n            border_pixels_to_erode=border_pixels_to_erode,\n            min_area_to_keep_border=min_area_to_keep_border,\n            use_pan_sharpening=use_pan_sharpening,\n        )\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Landsat9","title":"<code>Landsat9</code>","text":"<p>               Bases: <code>AbstractLandsat</code></p> <p>Satellite abstraction for Landsat 9 (OLI-2/TIRS-2 sensor, Collection 2).</p> <p>Landsat 9 is the latest mission in the Landsat program, launched in 2021. It is nearly identical to Landsat 8 and provides continuity for high-quality multispectral Earth observation. This class supports both TOA and SR products, with optional cloud masking using the QA_PIXEL band.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>set of str</code> <p>Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].</p> <code>None</code> <code>indices</code> <code>set of str</code> <p>Spectral indices to compute from the selected bands.</p> <code>None</code> <code>use_sr</code> <code>bool</code> <p>Whether to use surface reflectance products ('SR_B' bands). If False, uses top-of-atmosphere reflectance ('B' bands).</p> <code>True</code> <code>tier</code> <code>int</code> <p>Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.</p> <code>1</code> <code>use_cloud_mask</code> <code>bool</code> <p>Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>12</code> <code>toa_cloud_filter_strength</code> <code>int</code> <p>Strength of the additional cloud filter applied to TOA imagery (if use_sr=False). Used in the <code>remove_l_toa_tough_clouds</code> step.</p> <code>15</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>50_000</code> <code>use_pan_sharpening</code> <code>bool</code> <p>If True, applies pan sharpening to the RGB bands using the 15m-resolution panchromatic band (B8). Only applicable when <code>use_sr=False</code>. Raises ValueError if used with SR products.</p> <code>False</code> Cloud Masking <p>Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS: - Applied to both TOA and SR products when <code>use_cloud_mask=True</code> - For TOA collections, an additional filter (<code>remove_l_toa_tough_clouds</code>) is applied to remove low-quality observations based on a simple cloud scoring method.</p> Satellite Information <p>+----------------------------+------------------------+ | Field                      | Value                  | +----------------------------+------------------------+ | Name                       | Landsat 9 OLI-2/TIRS-2 | | Sensor                     | OLI-2 + TIRS-2         | | Platform                   | Landsat 9              | | Temporal Resolution        | 16 days                | | Pixel Size                 | 30 meters              | | Coverage                   | Global                 | +----------------------------+------------------------+</p> Collection Dates <p>+-------------+------------+------------+ | Product     | Start Date | End Date  | +-------------+------------+------------+ | TOA         | 2021-11-01 | present   | | SR          | 2021-11-01 | present   | +-------------+------------+------------+</p> Band Information <p>+-----------+----------+-----------+------------------------+ | Band Name | TOA Name | SR Name   | Spectral Wavelength    | +-----------+----------+-----------+------------------------+ | blue      | B2       | SR_B2     | 450-515 nm             | | green     | B3       | SR_B3     | 525-600 nm             | | red       | B4       | SR_B4     | 630-680 nm             | | nir       | B5       | SR_B5     | 845-885 nm             | | swir1     | B6       | SR_B6     | 1560-1660 nm           | | swir2     | B7       | SR_B7     | 2100-2300 nm           | | pan       | B8       |    \u2014      | 520-900 nm (panchromatic) | +-----------+----------+-----------+------------------------+</p> Notes <ul> <li> <p>Landsat 9 TOA Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T1_TOA</p> </li> <li> <p>Landsat 9 TOA Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T2_TOA</p> </li> <li> <p>Landsat 9 SR Collection (Tier 1):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T1_L2</p> </li> <li> <p>Landsat 9 SR Collection (Tier 2):     https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T2_L2</p> </li> <li> <p>Cloud mask reference (QA_PIXEL flags):     https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment</p> </li> <li> <p>TOA cloud filtering (Simple Cloud Score):     https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score</p> </li> </ul> Source code in <code>agrigee_lite/sat/landsat.py</code> <pre><code>class Landsat9(AbstractLandsat):\n    \"\"\"\n    Satellite abstraction for Landsat 9 (OLI-2/TIRS-2 sensor, Collection 2).\n\n    Landsat 9 is the latest mission in the Landsat program, launched in 2021. It is nearly identical to Landsat 8\n    and provides continuity for high-quality multispectral Earth observation. This class supports both TOA and SR\n    products, with optional cloud masking using the QA_PIXEL band.\n\n    Parameters\n    ----------\n    bands : set of str, optional\n        Set of bands to select. Defaults to ['blue', 'green', 'red', 'nir', 'swir1', 'swir2'].\n    indices : set of str, optional\n        Spectral indices to compute from the selected bands.\n    use_sr : bool, default=True\n        Whether to use surface reflectance products ('SR_B*' bands).\n        If False, uses top-of-atmosphere reflectance ('B*' bands).\n    tier : int, default=1\n        Landsat collection tier to use (1 or 2). Tier 1 has highest geometric accuracy.\n    use_cloud_mask : bool, default=True\n        Whether to apply QA_PIXEL-based cloud masking. If False, no cloud mask is applied.\n    min_valid_pixel_count : int, default=12\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    toa_cloud_filter_strength : int, default=15\n        Strength of the additional cloud filter applied to TOA imagery (if use_sr=False).\n        Used in the `remove_l_toa_tough_clouds` step.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=50_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n    use_pan_sharpening : bool, default=False\n        If True, applies pan sharpening to the RGB bands using the 15m-resolution panchromatic band (B8).\n        Only applicable when `use_sr=False`. Raises ValueError if used with SR products.\n\n    Cloud Masking\n    -------------\n    Cloud masking is based on the QA_PIXEL band, using bit flags defined by USGS:\n    - Applied to both TOA and SR products when `use_cloud_mask=True`\n    - For TOA collections, an additional filter (`remove_l_toa_tough_clouds`) is applied\n    to remove low-quality observations based on a simple cloud scoring method.\n\n    Satellite Information\n    ---------------------\n    +----------------------------+------------------------+\n    | Field                      | Value                  |\n    +----------------------------+------------------------+\n    | Name                       | Landsat 9 OLI-2/TIRS-2 |\n    | Sensor                     | OLI-2 + TIRS-2         |\n    | Platform                   | Landsat 9              |\n    | Temporal Resolution        | 16 days                |\n    | Pixel Size                 | 30 meters              |\n    | Coverage                   | Global                 |\n    +----------------------------+------------------------+\n\n    Collection Dates\n    ----------------\n    +-------------+------------+------------+\n    | Product     | Start Date | End Date  |\n    +-------------+------------+------------+\n    | TOA         | 2021-11-01 | present   |\n    | SR          | 2021-11-01 | present   |\n    +-------------+------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+----------+-----------+------------------------+\n    | Band Name | TOA Name | SR Name   | Spectral Wavelength    |\n    +-----------+----------+-----------+------------------------+\n    | blue      | B2       | SR_B2     | 450-515 nm             |\n    | green     | B3       | SR_B3     | 525-600 nm             |\n    | red       | B4       | SR_B4     | 630-680 nm             |\n    | nir       | B5       | SR_B5     | 845-885 nm             |\n    | swir1     | B6       | SR_B6     | 1560-1660 nm           |\n    | swir2     | B7       | SR_B7     | 2100-2300 nm           |\n    | pan       | B8       |    \u2014      | 520-900 nm (panchromatic) |\n    +-----------+----------+-----------+------------------------+\n\n    Notes\n    -----\n    - Landsat 9 TOA Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T1_TOA\n\n    - Landsat 9 TOA Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T2_TOA\n\n    - Landsat 9 SR Collection (Tier 1):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T1_L2\n\n    - Landsat 9 SR Collection (Tier 2):\n        https://developers.google.com/earth-engine/datasets/catalog/LANDSAT_LC09_C02_T2_L2\n\n    - Cloud mask reference (QA_PIXEL flags):\n        https://www.usgs.gov/media/files/landsat-collection-2-pixel-quality-assessment\n\n    - TOA cloud filtering (Simple Cloud Score):\n        https://developers.google.com/earth-engine/guides/landsat?hl=pt-br#simple-cloud-score\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        use_sr: bool = True,\n        tier: int = 1,\n        use_cloud_mask: bool = True,\n        min_valid_pixel_count: int = 12,\n        toa_cloud_filter_strength: int = 15,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 50_000,\n        use_pan_sharpening: bool = False,\n    ):\n        toa = {\"blue\": \"B2\", \"green\": \"B3\", \"red\": \"B4\", \"nir\": \"B5\", \"swir1\": \"B6\", \"swir2\": \"B7\", \"pan\": \"B8\"}\n        sr = {\n            \"blue\": \"SR_B2\",\n            \"green\": \"SR_B3\",\n            \"red\": \"SR_B4\",\n            \"nir\": \"SR_B5\",\n            \"swir1\": \"SR_B6\",\n            \"swir2\": \"SR_B7\",\n        }\n        super().__init__(\n            indices=indices,\n            sensor_code=\"LC09\",\n            toa_band_map=toa,\n            sr_band_map=sr,\n            short_base=\"l9\",\n            start_date=\"2021-11-01\",\n            end_date=\"2050-01-01\",\n            bands=bands,\n            use_sr=use_sr,\n            tier=tier,\n            use_cloud_mask=use_cloud_mask,\n            min_valid_pixel_count=min_valid_pixel_count,\n            toa_cloud_filter_strength=toa_cloud_filter_strength,\n            border_pixels_to_erode=border_pixels_to_erode,\n            min_area_to_keep_border=min_area_to_keep_border,\n            use_pan_sharpening=use_pan_sharpening,\n        )\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.MapBiomas","title":"<code>MapBiomas</code>","text":"<p>               Bases: <code>DataSourceSatellite</code></p> <p>Satellite abstraction for MapBiomas Brazil Collection 10 Land Use and Land Cover (LULC) data.</p> <p>This class wraps the official MapBiomas Collection 10 LULC classification product for Brazil. The dataset provides annual land use and land cover classifications from 1985 to 2023 at 30-meter resolution, with majority class (<code>10_class</code>) and percent agreement (<code>11_percent</code>) bands.</p> <p>It is suitable for long-term land cover trend analysis, ecosystem monitoring, and environmental assessments.</p> <p>Parameters:</p> Name Type Description Default <code>border_pixels_to_erode</code> <code>float</code> <p>Number of border pixels (in pixels) to erode from the input geometry before analysis. Helps remove classification noise from edges. Use 0 to disable.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area in square meters to retain the eroded region. Used to avoid discarding small geometries entirely.</p> <code>50000</code> Bands <p>+-------------+------------------------+-------------------------------------------------------------+ | Band Name   | Type                   | Description                                                 | +-------------+------------------------+-------------------------------------------------------------+ | 10_class    | Categorical (int)      | Most frequent land use/cover class for the pixel/year       | | 11_percent  | Float (0-1)            | Proportion of classification votes for the majority class   | +-------------+------------------------+-------------------------------------------------------------+</p> <p>Classes:</p> Name Description <code>Each integer value in the `10_class` band corresponds to a LULC class defined by MapBiomas.</code> <code>Refer to `self.classes` for full label and color mapping. Examples include:</code> <code>- 3: Forest Formation</code> <code>- 14: Farming</code> <code>- 24: Urban Area</code> <code>- 26: Water</code> <code>- 39: Soybean</code> <code>- 46: Coffee</code> Processing Overview <ol> <li>The MapBiomas classification image (<code>mapbiomas_brazil_collection10_coverage_v2</code>) is loaded.</li> <li>For each year between the start and end date of the input feature:</li> <li>The modal (most frequent) class is computed (<code>10_class</code>)</li> <li>Its pixel agreement (% of pixels matching that class) is calculated (<code>11_percent</code>)</li> <li>Optionally, the geometry is eroded to avoid edge noise.</li> <li>Final features are returned as an annual time series of LULC summaries.</li> </ol> Dataset Information <p>+-------------------------+------------------------------------------------------+ | Field                   | Value                                                | +-------------------------+------------------------------------------------------+ | Dataset                 | MapBiomas Brazil Collection 10                       | | Temporal Coverage       | 1985 - 2023                                          | | Spatial Resolution      | 30 meters                                            | | Projection              | EPSG: 4674 (SIRGAS 2000)                             | | Source Imagery          | Landsat (TM, ETM+, OLI)                              | | Classification Method   | Random Forest + Temporal Filtering                   | +-------------------------+------------------------------------------------------+</p> Notes <ul> <li> <p>Official MapBiomas dataset (Earth Engine): https://developers.google.com/earth-engine/datasets/catalog/projects_mapbiomas-public_assets_brazil_lulc_collection10_mapbiomas_brazil_collection10_coverage_v2</p> </li> <li> <p>ATBD (Algorithm Theoretical Basis Document) Collection 10: https://mapbiomas.org/downloads?cama_set_language=en</p> </li> <li> <p>Only the majority class (<code>classification_YEAR</code>) is used here \u2014 secondary confidence or transitions are not included.</p> </li> </ul> Source code in <code>agrigee_lite/sat/mapbiomas.py</code> <pre><code>class MapBiomas(DataSourceSatellite):\n    \"\"\"\n    Satellite abstraction for MapBiomas Brazil Collection 10 Land Use and Land Cover (LULC) data.\n\n    This class wraps the official MapBiomas Collection 10 LULC classification product for Brazil.\n    The dataset provides annual land use and land cover classifications from 1985 to 2023 at 30-meter resolution,\n    with majority class (`10_class`) and percent agreement (`11_percent`) bands.\n\n    It is suitable for long-term land cover trend analysis, ecosystem monitoring, and environmental assessments.\n\n    Parameters\n    ----------\n    border_pixels_to_erode : float, default=1\n        Number of border pixels (in pixels) to erode from the input geometry before analysis.\n        Helps remove classification noise from edges. Use 0 to disable.\n    min_area_to_keep_border : int, default=50000\n        Minimum area in square meters to retain the eroded region.\n        Used to avoid discarding small geometries entirely.\n\n    Bands\n    -----\n    +-------------+------------------------+-------------------------------------------------------------+\n    | Band Name   | Type                   | Description                                                 |\n    +-------------+------------------------+-------------------------------------------------------------+\n    | 10_class    | Categorical (int)      | Most frequent land use/cover class for the pixel/year       |\n    | 11_percent  | Float (0-1)            | Proportion of classification votes for the majority class   |\n    +-------------+------------------------+-------------------------------------------------------------+\n\n    Classes\n    -------\n    Each integer value in the `10_class` band corresponds to a LULC class defined by MapBiomas.\n    Refer to `self.classes` for full label and color mapping. Examples include:\n    - 3: Forest Formation\n    - 14: Farming\n    - 24: Urban Area\n    - 26: Water\n    - 39: Soybean\n    - 46: Coffee\n\n    Processing Overview\n    -------------------\n    1. The MapBiomas classification image (`mapbiomas_brazil_collection10_coverage_v2`) is loaded.\n    2. For each year between the start and end date of the input feature:\n    - The modal (most frequent) class is computed (`10_class`)\n    - Its pixel agreement (% of pixels matching that class) is calculated (`11_percent`)\n    3. Optionally, the geometry is eroded to avoid edge noise.\n    4. Final features are returned as an annual time series of LULC summaries.\n\n    Dataset Information\n    -------------------\n    +-------------------------+------------------------------------------------------+\n    | Field                   | Value                                                |\n    +-------------------------+------------------------------------------------------+\n    | Dataset                 | MapBiomas Brazil Collection 10                       |\n    | Temporal Coverage       | 1985 - 2023                                          |\n    | Spatial Resolution      | 30 meters                                            |\n    | Projection              | EPSG: 4674 (SIRGAS 2000)                             |\n    | Source Imagery          | Landsat (TM, ETM+, OLI)                              |\n    | Classification Method   | Random Forest + Temporal Filtering                   |\n    +-------------------------+------------------------------------------------------+\n\n    Notes\n    -----\n    - Official MapBiomas dataset (Earth Engine):\n    https://developers.google.com/earth-engine/datasets/catalog/projects_mapbiomas-public_assets_brazil_lulc_collection10_mapbiomas_brazil_collection10_coverage_v2\n\n    - ATBD (Algorithm Theoretical Basis Document) Collection 10:\n    https://mapbiomas.org/downloads?cama_set_language=en\n\n    - Only the majority class (`classification_YEAR`) is used here \u2014 secondary confidence or transitions are not included.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 50_000,\n    ) -&gt; None:\n        super().__init__()\n        self.imageAsset: str = (\n            \"projects/mapbiomas-public/assets/brazil/lulc/collection10/mapbiomas_brazil_collection10_coverage_v2\"\n        )\n        self.pixelSize: int = 30\n        self.startDate = \"1985-01-01\"\n        self.endDate = \"2024-01-01\"\n        self.shortName = \"mapbiomasmajclass\"\n        self.selectedBands = [\n            (None, \"10_class\"),\n            (None, \"11_percent\"),\n        ]\n\n        self.classes = {\n            1: {\"label\": \"Forest\", \"color\": \"#1f8d49\"},\n            3: {\"label\": \"Forest Formation\", \"color\": \"#1f8d49\"},\n            4: {\"label\": \"Savanna Formation\", \"color\": \"#7dc975\"},\n            5: {\"label\": \"Mangrove\", \"color\": \"#04381d\"},\n            6: {\"label\": \"Floodable Forest\", \"color\": \"#007785\"},\n            9: {\"label\": \"Forest Plantation\", \"color\": \"#7a5900\"},\n            10: {\"label\": \"Herbaceous and Shrubby Vegetation\", \"color\": \"#d6bc74\"},\n            11: {\"label\": \"Wetland\", \"color\": \"#519799\"},\n            12: {\"label\": \"Grassland\", \"color\": \"#d6bc74\"},\n            14: {\"label\": \"Farming\", \"color\": \"#ffefc3\"},\n            15: {\"label\": \"Pasture\", \"color\": \"#edde8e\"},\n            18: {\"label\": \"Agriculture\", \"color\": \"#E974ED\"},\n            19: {\"label\": \"Temporary Crop\", \"color\": \"#C27BA0\"},\n            20: {\"label\": \"Sugar cane\", \"color\": \"#db7093\"},\n            21: {\"label\": \"Mosaic of Uses\", \"color\": \"#ffefc3\"},\n            22: {\"label\": \"Non vegetated area\", \"color\": \"#d4271e\"},\n            23: {\"label\": \"Beach, Dune and Sand Spot\", \"color\": \"#ffa07a\"},\n            24: {\"label\": \"Urban Area\", \"color\": \"#d4271e\"},\n            25: {\"label\": \"Other non Vegetated Areas\", \"color\": \"#db4d4f\"},\n            26: {\"label\": \"Water\", \"color\": \"#2532e4\"},\n            27: {\"label\": \"Not Observed\", \"color\": \"#ffffff\"},\n            29: {\"label\": \"Rocky Outcrop\", \"color\": \"#ffaa5f\"},\n            30: {\"label\": \"Mining\", \"color\": \"#9c0027\"},\n            31: {\"label\": \"Aquaculture\", \"color\": \"#091077\"},\n            32: {\"label\": \"Hypersaline Tidal Flat\", \"color\": \"#fc8114\"},\n            33: {\"label\": \"River, Lake and Ocean\", \"color\": \"#2532e4\"},\n            35: {\"label\": \"Palm Oil\", \"color\": \"#9065d0\"},\n            36: {\"label\": \"Perennial Crop\", \"color\": \"#d082de\"},\n            39: {\"label\": \"Soybean\", \"color\": \"#f5b3c8\"},\n            40: {\"label\": \"Rice\", \"color\": \"#c71585\"},\n            41: {\"label\": \"Other Temporary Crops\", \"color\": \"#f54ca9\"},\n            46: {\"label\": \"Coffee\", \"color\": \"#d68fe2\"},\n            47: {\"label\": \"Citrus\", \"color\": \"#9932cc\"},\n            48: {\"label\": \"Other Perennial Crops\", \"color\": \"#e6ccff\"},\n            49: {\"label\": \"Wooded Sandbank Vegetation\", \"color\": \"#02d659\"},\n            50: {\"label\": \"Herbaceous Sandbank Vegetation\", \"color\": \"#ad5100\"},\n            62: {\"label\": \"Cotton (beta)\", \"color\": \"#ff69b4\"},\n            75: {\"label\": \"Photovoltaic Power Plant (beta)\", \"color\": \"#c12100\"},\n        }\n\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n        self.toDownloadSelectors = [\"10_class\", \"11_percent\"]\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float | None = None,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        mb_image = ee.Image(self.imageAsset)\n        mb_image = ee_map_valid_pixels(mb_image, ee_geometry, self.pixelSize)\n\n        ee_start = ee.Feature(ee_feature).get(\"s\")\n        ee_end = ee.Feature(ee_feature).get(\"e\")\n        start_year = ee.Date(ee_start).get(\"year\")\n        end_year = ee.Date(ee_end).get(\"year\")\n        indexnum = ee.Feature(ee_feature).get(\"0\")\n\n        years = ee.List.sequence(start_year, end_year)\n\n        def _feat_for_year(year: ee.Number) -&gt; ee.Feature:\n            year_num = ee.Number(year).toInt()\n            year_str = year_num.format()\n            band_in = ee.String(\"classification_\").cat(year_str)\n            img = mb_image.select([band_in], [year_str])\n\n            mode_dict = img.reduceRegion(\n                reducer=ee.Reducer.mode(),\n                geometry=ee_geometry,\n                scale=self.pixelSize,\n                maxPixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n                bestEffort=True,\n            )\n            clazz = ee.Number(mode_dict.get(year_str)).round()\n\n            percent = (\n                img.eq(clazz)\n                .reduceRegion(\n                    reducer=ee.Reducer.mean(),\n                    geometry=ee_geometry,\n                    scale=self.pixelSize,\n                    maxPixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n                    bestEffort=True,\n                )\n                .get(year_str)\n            )\n\n            timestamp = ee.String(year_str).cat(\"-01-01\")\n\n            stats = ee.Feature(\n                None,\n                {\n                    \"00_indexnum\": indexnum,\n                    \"01_timestamp\": timestamp,\n                    \"10_class\": clazz,\n                    \"11_percent\": percent,\n                },\n            )\n\n            stats = stats.set(\"99_validPixelsCount\", mb_image.get(\"ZZ_USER_VALID_PIXELS\"))\n\n            return stats\n\n        features = years.map(_feat_for_year)\n        return ee.FeatureCollection(features)\n\n    def __str__(self) -&gt; str:\n        return self.shortName\n\n    def __repr__(self) -&gt; str:\n        return self.shortName\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Modis8Days","title":"<code>Modis8Days</code>","text":"<p>               Bases: <code>OpticalSatellite</code></p> <p>Satellite abstraction for MODIS Terra and Aqua (8-day composites).</p> <p>MODIS (Moderate Resolution Imaging Spectroradiometer) is a key instrument aboard NASA's Terra and Aqua satellites, providing global coverage for land, ocean, and atmospheric monitoring at frequent intervals.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>list of str</code> <p>List of bands to select. Defaults to ['red', 'nir'].</p> <code>None</code> <code>indices</code> <code>list of str</code> <p>List of spectral indices to compute from selected bands.</p> <code>None</code> <code>use_cloud_mask</code> <code>bool</code> <p>Whether to apply a cloud mask based on the QA 'State' band (bits 0-1). If True, only pixels with cloud state == 0 (clear) are retained.</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>2</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>0.5</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>190_000</code> Cloud Masking <p>Cloudy pixels are masked using bits 0-1 of the 'State' QA band, which encode cloud state:     - 00: clear     - 01: cloudy     - 10: mixed     - 11: not set</p> <p>The masking keeps only pixels with value 00 (clear) if <code>use_cloud_mask=True</code>.</p> Satellite Information <p>+----------------------------+------------------------+ | Field                      | Value                  | +----------------------------+------------------------+ | Name                       | MODIS (8-day)          | | Platforms                  | Terra, Aqua            | | Temporal Resolution        | 8 days                 | | Pixel Size                 | 250 meters             | | Coverage                   | Global                 | +----------------------------+------------------------+</p> Collection Dates <p>+--------+------------+------------+ | Source | Start Date | End Date  | +--------+------------+------------+ | Terra  | 2000-02-18 | present   | | Aqua   | 2002-07-04 | present   | +--------+------------+------------+</p> Band Information <p>+-----------+----------------+----------------+------------------------+ | Band Name | Original Band  | Resolution     | Spectral Wavelength    | +-----------+----------------+----------------+------------------------+ | red       | sur_refl_b01   | 250 meters     | 620-670 nm             | | nir       | sur_refl_b02   | 250 meters     | 841-876 nm             | +-----------+----------------+----------------+------------------------+</p> Notes <p>Cloud Mask Reference (QA 'State' band documentation):     https://lpdaac.usgs.gov/documents/925/MOD09_User_Guide_V61.pdf</p> <p>MODIS Collections on Google Earth Engine:     - Terra (MOD09Q1): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MOD09Q1     - Aqua  (MYD09Q1): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MYD09Q1</p> Source code in <code>agrigee_lite/sat/modis.py</code> <pre><code>class Modis8Days(OpticalSatellite):\n    \"\"\"\n    Satellite abstraction for MODIS Terra and Aqua (8-day composites).\n\n    MODIS (Moderate Resolution Imaging Spectroradiometer) is a key instrument aboard NASA's Terra and Aqua satellites,\n    providing global coverage for land, ocean, and atmospheric monitoring at frequent intervals.\n\n    Parameters\n    ----------\n    bands : list of str, optional\n        List of bands to select. Defaults to ['red', 'nir'].\n    indices : list of str, optional\n        List of spectral indices to compute from selected bands.\n    use_cloud_mask : bool, default=True\n        Whether to apply a cloud mask based on the QA 'State' band (bits 0-1).\n        If True, only pixels with cloud state == 0 (clear) are retained.\n    min_valid_pixel_count : int, default=2\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    border_pixels_to_erode : float, default=0.5\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=190_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Cloud Masking\n    -------------\n    Cloudy pixels are masked using bits 0-1 of the 'State' QA band, which encode cloud state:\n        - 00: clear\n        - 01: cloudy\n        - 10: mixed\n        - 11: not set\n\n    The masking keeps only pixels with value 00 (clear) if `use_cloud_mask=True`.\n\n    Satellite Information\n    ---------------------\n    +----------------------------+------------------------+\n    | Field                      | Value                  |\n    +----------------------------+------------------------+\n    | Name                       | MODIS (8-day)          |\n    | Platforms                  | Terra, Aqua            |\n    | Temporal Resolution        | 8 days                 |\n    | Pixel Size                 | 250 meters             |\n    | Coverage                   | Global                 |\n    +----------------------------+------------------------+\n\n    Collection Dates\n    ----------------\n    +--------+------------+------------+\n    | Source | Start Date | End Date  |\n    +--------+------------+------------+\n    | Terra  | 2000-02-18 | present   |\n    | Aqua   | 2002-07-04 | present   |\n    +--------+------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+----------------+----------------+------------------------+\n    | Band Name | Original Band  | Resolution     | Spectral Wavelength    |\n    +-----------+----------------+----------------+------------------------+\n    | red       | sur_refl_b01   | 250 meters     | 620-670 nm             |\n    | nir       | sur_refl_b02   | 250 meters     | 841-876 nm             |\n    +-----------+----------------+----------------+------------------------+\n\n    Notes\n    -----\n    Cloud Mask Reference (QA 'State' band documentation):\n        https://lpdaac.usgs.gov/documents/925/MOD09_User_Guide_V61.pdf\n\n    MODIS Collections on Google Earth Engine:\n        - Terra (MOD09Q1): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MOD09Q1\n        - Aqua  (MYD09Q1): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MYD09Q1\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: list[str] | None = None,\n        indices: list[str] | None = None,\n        use_cloud_mask: bool = True,\n        min_valid_pixel_count: int = 2,\n        border_pixels_to_erode: float = 0.5,\n        min_area_to_keep_border: int = 190_000,\n    ) -&gt; None:\n        bands = sorted({\"red\", \"nir\"}) if bands is None else sorted(bands)\n\n        indices = [] if indices is None else sorted(indices)\n\n        super().__init__()\n\n        self.shortName = \"modis8days\"\n        self.pixelSize = 250\n        self.startDate = \"2000-02-18\"\n        self.endDate = \"2050-01-01\"\n\n        self._terra = \"MODIS/061/MOD09Q1\"\n        self._aqua = \"MODIS/061/MYD09Q1\"\n\n        self.availableBands = {\n            \"red\": \"sur_refl_b01\",\n            \"nir\": \"sur_refl_b02\",\n        }\n\n        self.selectedBands: list[tuple[str, str]] = [(band, f\"{(n + 10):02}_{band}\") for n, band in enumerate(bands)]\n\n        self.selectedIndices: list[str] = [\n            (self.availableIndices[indice_name], indice_name, f\"{(n + 40):02}_{indice_name}\")\n            for n, indice_name in enumerate(indices)\n        ]\n\n        self.useCloudMask = use_cloud_mask\n        self.minValidPixelCount = min_valid_pixel_count\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n\n        self.toDownloadSelectors = [numeral_band_name for _, numeral_band_name in self.selectedBands] + [\n            numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices\n        ]\n\n    @staticmethod\n    def _mask_modis8days_clouds(img: ee.Image) -&gt; ee.Image:\n        \"\"\"Mask cloudy pixels based on bits 0-1 of 'State' QA band.\"\"\"\n        qa = img.select(\"State\")\n        cloud_state = qa.bitwiseAnd(3)  # 3 == 0b11\n        return img.updateMask(cloud_state.eq(0))\n\n    def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        ee_filter = ee.Filter.And(\n            ee.Filter.bounds(ee_geometry),\n            ee.Filter.date(ee_feature.get(\"s\"), ee_feature.get(\"e\")),\n        )\n\n        def _base(path: str) -&gt; ee.ImageCollection:\n            collection = ee.ImageCollection(path).filter(ee_filter)\n            if self.useCloudMask:\n                collection = collection.map(self._mask_modis8days_clouds)\n\n            return collection.select(\n                list(self.availableBands.values()),\n                list(self.availableBands.keys()),\n            )\n\n        terra = _base(self._terra)\n        aqua = _base(self._aqua)\n\n        modis_imgc = terra.merge(aqua)\n\n        modis_imgc = modis_imgc.map(\n            lambda img: ee.Image(img).addBands(ee.Image(img).add(100).divide(16_100), overwrite=True)\n        )\n\n        if self.selectedIndices:\n            modis_imgc = modis_imgc.map(\n                partial(ee_add_indexes_to_image, indexes=[expression for (expression, _, _) in self.selectedIndices])\n            )\n\n        modis_imgc = modis_imgc.select(\n            [natural_band_name for natural_band_name, _ in self.selectedBands]\n            + [indice_name for _, indice_name, _ in self.selectedIndices],\n            [numeral_band_name for _, numeral_band_name in self.selectedBands]\n            + [numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices],\n        )\n\n        modis_imgc = ee_filter_img_collection_invalid_pixels(\n            modis_imgc, ee_geometry, self.pixelSize, self.minValidPixelCount\n        )\n\n        return ee.ImageCollection(modis_imgc)\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        geom = ee_feature.geometry()\n        geom = ee_safe_remove_borders(geom, self.pixelSize // 2, 190_000)\n        ee_feature = ee_feature.setGeometry(geom)\n\n        modis = self.imageCollection(ee_feature)\n\n        feats = modis.map(\n            partial(\n                ee_map_bands_and_doy,\n                ee_feature=ee_feature,\n                pixel_size=self.pixelSize,\n                subsampling_max_pixels=ee_get_number_of_pixels(geom, subsampling_max_pixels, self.pixelSize),\n                reducer=ee_get_reducers(reducers),\n            )\n        )\n        return feats\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Modis8Days._mask_modis8days_clouds","title":"<code>_mask_modis8days_clouds(img)</code>  <code>staticmethod</code>","text":"<p>Mask cloudy pixels based on bits 0-1 of 'State' QA band.</p> Source code in <code>agrigee_lite/sat/modis.py</code> <pre><code>@staticmethod\ndef _mask_modis8days_clouds(img: ee.Image) -&gt; ee.Image:\n    \"\"\"Mask cloudy pixels based on bits 0-1 of 'State' QA band.\"\"\"\n    qa = img.select(\"State\")\n    cloud_state = qa.bitwiseAnd(3)  # 3 == 0b11\n    return img.updateMask(cloud_state.eq(0))\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.ModisDaily","title":"<code>ModisDaily</code>","text":"<p>               Bases: <code>OpticalSatellite</code></p> <p>\u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f  Note: Despite this cloud mask, daily MODIS imagery tends to have a high presence of residual clouds. It is recommended to use Modis8Days for cleaner data. \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f</p> <p>Satellite abstraction for MODIS Terra and Aqua (Daily composites).</p> <p>MODIS (Moderate Resolution Imaging Spectroradiometer) is a key instrument aboard NASA's Terra and Aqua satellites, offering daily global coverage for environmental and land surface monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>set of str</code> <p>Set of bands to select. Defaults to ['red', 'nir'].</p> <code>None</code> <code>indices</code> <code>set of str</code> <p>List of spectral indices to compute from selected bands.</p> <code>None</code> <code>use_cloud_mask</code> <code>bool</code> <p>Whether to apply cloud masking using bit 10 of the 'state_1km' QA band. When set to False, no cloud filtering is applied (results may be ULTRA NOISY).</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>2</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>0.5</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>190_000</code> Cloud Masking <p>Cloudy pixels are masked using bit 10 of the 'state_1km' QA band:     - 0: clear     - 1: cloudy</p> <p>Only pixels with bit 10 equal to 0 (clear) are retained.</p> Satellite Information <p>+----------------------------+------------------------+ | Field                      | Value                  | +----------------------------+------------------------+ | Name                       | MODIS (Daily)          | | Platforms                  | Terra, Aqua            | | Temporal Resolution        | 1 day                  | | Pixel Size                 | 250 meters             | | Coverage                   | Global                 | +----------------------------+------------------------+</p> Collection Dates <p>+--------+------------+------------+ | Source | Start Date | End Date  | +--------+------------+------------+ | Terra  | 2000-02-24 | present   | | Aqua   | 2002-07-04 | present   | +--------+------------+------------+</p> Band Information <p>+-----------+----------------+----------------+------------------------+ | Band Name | Original Band  | Resolution     | Spectral Wavelength    | +-----------+----------------+----------------+------------------------+ | red       | sur_refl_b01   | 250 meters     | 620-670 nm             | | nir       | sur_refl_b02   | 250 meters     | 841-876 nm             | +-----------+----------------+----------------+------------------------+</p> Notes <p>Cloud Mask Reference (QA 'state_1km' band documentation):     https://lpdaac.usgs.gov/documents/925/MOD09_User_Guide_V61.pdf</p> <p>MODIS Collections on Google Earth Engine:     - Terra (MOD09GQ - reflectance): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MOD09GQ     - Terra (MOD09GA - QA band):     https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MOD09GA     - Aqua  (MYD09GQ - reflectance): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MYD09GQ     - Aqua  (MYD09GA - QA band):     https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MYD09GA</p> Source code in <code>agrigee_lite/sat/modis.py</code> <pre><code>class ModisDaily(OpticalSatellite):\n    \"\"\"\n    \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f  Note: Despite this cloud mask, daily MODIS imagery tends to have **a high presence of residual clouds**. It is recommended to use Modis8Days for cleaner data. \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f\n\n    Satellite abstraction for MODIS Terra and Aqua (Daily composites).\n\n    MODIS (Moderate Resolution Imaging Spectroradiometer) is a key instrument aboard NASA's Terra and Aqua satellites,\n    offering daily global coverage for environmental and land surface monitoring.\n\n    Parameters\n    ----------\n    bands : set of str, optional\n        Set of bands to select. Defaults to ['red', 'nir'].\n    indices : set of str, optional\n        List of spectral indices to compute from selected bands.\n    use_cloud_mask : bool, default=True\n        Whether to apply cloud masking using bit 10 of the 'state_1km' QA band.\n        When set to False, no cloud filtering is applied (results may be ULTRA NOISY).\n    min_valid_pixel_count : int, default=2\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    border_pixels_to_erode : float, default=0.5\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=190_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Cloud Masking\n    -------------\n    Cloudy pixels are masked using bit 10 of the 'state_1km' QA band:\n        - 0: clear\n        - 1: cloudy\n\n    Only pixels with bit 10 equal to 0 (clear) are retained.\n\n    Satellite Information\n    ---------------------\n    +----------------------------+------------------------+\n    | Field                      | Value                  |\n    +----------------------------+------------------------+\n    | Name                       | MODIS (Daily)          |\n    | Platforms                  | Terra, Aqua            |\n    | Temporal Resolution        | 1 day                  |\n    | Pixel Size                 | 250 meters             |\n    | Coverage                   | Global                 |\n    +----------------------------+------------------------+\n\n    Collection Dates\n    ----------------\n    +--------+------------+------------+\n    | Source | Start Date | End Date  |\n    +--------+------------+------------+\n    | Terra  | 2000-02-24 | present   |\n    | Aqua   | 2002-07-04 | present   |\n    +--------+------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+----------------+----------------+------------------------+\n    | Band Name | Original Band  | Resolution     | Spectral Wavelength    |\n    +-----------+----------------+----------------+------------------------+\n    | red       | sur_refl_b01   | 250 meters     | 620-670 nm             |\n    | nir       | sur_refl_b02   | 250 meters     | 841-876 nm             |\n    +-----------+----------------+----------------+------------------------+\n\n    Notes\n    -----\n    Cloud Mask Reference (QA 'state_1km' band documentation):\n        https://lpdaac.usgs.gov/documents/925/MOD09_User_Guide_V61.pdf\n\n    MODIS Collections on Google Earth Engine:\n        - Terra (MOD09GQ - reflectance): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MOD09GQ\n        - Terra (MOD09GA - QA band):     https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MOD09GA\n        - Aqua  (MYD09GQ - reflectance): https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MYD09GQ\n        - Aqua  (MYD09GA - QA band):     https://developers.google.com/earth-engine/datasets/catalog/MODIS_061_MYD09GA\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        use_cloud_mask: bool = True,\n        min_valid_pixel_count: int = 2,\n        border_pixels_to_erode: float = 0.5,\n        min_area_to_keep_border: int = 190_000,\n    ) -&gt; None:\n        bands = sorted({\"red\", \"nir\"}) if bands is None else sorted(bands)\n\n        indices = [] if indices is None else sorted(indices)\n\n        super().__init__()\n\n        self.shortName = \"modis\"\n        self.pixelSize = 250\n        self.startDate = \"2000-02-24\"\n        self.endDate = \"2050-01-01\"\n\n        self._terra_vis = \"MODIS/061/MOD09GQ\"\n        self._terra_qa = \"MODIS/061/MOD09GA\"\n        self._aqua_vis = \"MODIS/061/MYD09GQ\"\n        self._aqua_qa = \"MODIS/061/MYD09GA\"\n\n        self.availableBands = {\n            \"red\": \"sur_refl_b01\",\n            \"nir\": \"sur_refl_b02\",\n        }\n\n        self.selectedBands: list[tuple[str, str]] = [(band, f\"{(n + 10):02}_{band}\") for n, band in enumerate(bands)]\n\n        self.selectedIndices: list[str] = [\n            (self.availableIndices[indice_name], indice_name, f\"{(n + 40):02}_{indice_name}\")\n            for n, indice_name in enumerate(indices)\n        ]\n\n        self.useCloudMask = use_cloud_mask\n        self.minValidPixelCount = min_valid_pixel_count\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n\n        self.toDownloadSelectors = [numeral_band_name for _, numeral_band_name in self.selectedBands] + [\n            numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices\n        ]\n\n    @staticmethod\n    def _mask_modis_clouds(img: ee.Image) -&gt; ee.Image:\n        \"\"\"Bit-test bit 10 of *state_1km* (value 0 = clear).\"\"\"\n        qa = img.select(\"state_1km\")\n        bit_mask = 1 &lt;&lt; 10\n        return img.updateMask(qa.bitwiseAnd(bit_mask).eq(0))\n\n    def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n        \"\"\"\n        Build the merged, cloud-masked Terra + Aqua collection *exactly*\n        like the stand-alone helper did.\n        \"\"\"\n        ee_geometry = ee_feature.geometry()\n        ee_filter = ee.Filter.And(\n            ee.Filter.bounds(ee_geometry),\n            ee.Filter.date(ee_feature.get(\"s\"), ee_feature.get(\"e\")),\n        )\n\n        def _base(vis: str, qa: str) -&gt; ee.ImageCollection:\n            collection = ee.ImageCollection(vis).linkCollection(ee.ImageCollection(qa), [\"state_1km\"]).filter(ee_filter)\n            if self.useCloudMask:\n                collection = collection.map(self._mask_modis_clouds)\n\n            return collection.select(\n                list(self.availableBands.values()),\n                list(self.availableBands.keys()),\n            )\n\n        terra = _base(self._terra_vis, self._terra_qa)\n        aqua = _base(self._aqua_vis, self._aqua_qa)\n\n        modis_imgc = terra.merge(aqua)\n\n        modis_imgc = modis_imgc.map(\n            lambda img: ee.Image(img).addBands(ee.Image(img).add(100).divide(16_100), overwrite=True)\n        )\n\n        if self.selectedIndices:\n            modis_imgc = modis_imgc.map(\n                partial(ee_add_indexes_to_image, indexes=[expression for (expression, _, _) in self.selectedIndices])\n            )\n\n        modis_imgc = modis_imgc.select(\n            [natural_band_name for natural_band_name, _ in self.selectedBands]\n            + [indice_name for _, indice_name, _ in self.selectedIndices],\n            [numeral_band_name for _, numeral_band_name in self.selectedBands]\n            + [numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices],\n        )\n\n        modis_imgc = ee_filter_img_collection_invalid_pixels(\n            modis_imgc, ee_geometry, self.pixelSize, self.minValidPixelCount\n        )\n\n        return ee.ImageCollection(modis_imgc)\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        modis = self.imageCollection(ee_feature)\n\n        feats = modis.map(\n            partial(\n                ee_map_bands_and_doy,\n                ee_feature=ee_feature,\n                pixel_size=self.pixelSize,\n                subsampling_max_pixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n                reducer=ee_get_reducers(reducers),\n            )\n        )\n        return feats\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.ModisDaily._mask_modis_clouds","title":"<code>_mask_modis_clouds(img)</code>  <code>staticmethod</code>","text":"<p>Bit-test bit 10 of state_1km (value 0 = clear).</p> Source code in <code>agrigee_lite/sat/modis.py</code> <pre><code>@staticmethod\ndef _mask_modis_clouds(img: ee.Image) -&gt; ee.Image:\n    \"\"\"Bit-test bit 10 of *state_1km* (value 0 = clear).\"\"\"\n    qa = img.select(\"state_1km\")\n    bit_mask = 1 &lt;&lt; 10\n    return img.updateMask(qa.bitwiseAnd(bit_mask).eq(0))\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.ModisDaily.imageCollection","title":"<code>imageCollection(ee_feature)</code>","text":"<p>Build the merged, cloud-masked Terra + Aqua collection exactly like the stand-alone helper did.</p> Source code in <code>agrigee_lite/sat/modis.py</code> <pre><code>def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n    \"\"\"\n    Build the merged, cloud-masked Terra + Aqua collection *exactly*\n    like the stand-alone helper did.\n    \"\"\"\n    ee_geometry = ee_feature.geometry()\n    ee_filter = ee.Filter.And(\n        ee.Filter.bounds(ee_geometry),\n        ee.Filter.date(ee_feature.get(\"s\"), ee_feature.get(\"e\")),\n    )\n\n    def _base(vis: str, qa: str) -&gt; ee.ImageCollection:\n        collection = ee.ImageCollection(vis).linkCollection(ee.ImageCollection(qa), [\"state_1km\"]).filter(ee_filter)\n        if self.useCloudMask:\n            collection = collection.map(self._mask_modis_clouds)\n\n        return collection.select(\n            list(self.availableBands.values()),\n            list(self.availableBands.keys()),\n        )\n\n    terra = _base(self._terra_vis, self._terra_qa)\n    aqua = _base(self._aqua_vis, self._aqua_qa)\n\n    modis_imgc = terra.merge(aqua)\n\n    modis_imgc = modis_imgc.map(\n        lambda img: ee.Image(img).addBands(ee.Image(img).add(100).divide(16_100), overwrite=True)\n    )\n\n    if self.selectedIndices:\n        modis_imgc = modis_imgc.map(\n            partial(ee_add_indexes_to_image, indexes=[expression for (expression, _, _) in self.selectedIndices])\n        )\n\n    modis_imgc = modis_imgc.select(\n        [natural_band_name for natural_band_name, _ in self.selectedBands]\n        + [indice_name for _, indice_name, _ in self.selectedIndices],\n        [numeral_band_name for _, numeral_band_name in self.selectedBands]\n        + [numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices],\n    )\n\n    modis_imgc = ee_filter_img_collection_invalid_pixels(\n        modis_imgc, ee_geometry, self.pixelSize, self.minValidPixelCount\n    )\n\n    return ee.ImageCollection(modis_imgc)\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.PALSAR2ScanSAR","title":"<code>PALSAR2ScanSAR</code>","text":"<p>               Bases: <code>RadarSatellite</code></p> <p>Satellite abstraction for ALOS PALSAR-2 ScanSAR (Level 2.2).</p> <p>PALSAR-2 is an L-band Synthetic Aperture Radar (SAR) sensor onboard the ALOS-2 satellite, operated by JAXA. This class provides preprocessing and abstraction for the Level 2.2 ScanSAR data product with 25-meter resolution. Optionally applies the MSK quality mask.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>set of str</code> <p>Set of bands to select. Defaults to ['hh', 'hv'].</p> <code>None</code> <code>indices</code> <code>set of str</code> <p>Radar indices to compute (e.g., polarization ratios). Defaults to [].</p> <code>None</code> <code>use_quality_mask</code> <code>bool</code> <p>Whether to apply the MSK bitmask quality filter. If False, all pixels are retained, including those marked as low-quality or invalid.</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>20</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>35_000</code> Quality Masking <p>When <code>use_quality_mask=True</code>, the <code>MSK</code> band is used to filter out invalid pixels. The first 3 bits of the <code>MSK</code> band indicate data quality:     - 1 \u2192 Valid     - 5 \u2192 Invalid Only pixels with value 1 are retained.</p> Satellite Information <p>+----------------------------+-------------------------------+ | Field                      | Value                         | +----------------------------+-------------------------------+ | Name                       | ALOS PALSAR-2 ScanSAR         | | Sensor                     | PALSAR-2 (L-band SAR)         | | Platform                   | ALOS-2                        | | Revisit Time               | ~14 days                      | | Pixel Size                 | ~25 meters                    | | Coverage                   | Japan + selected global areas | +----------------------------+-------------------------------+</p> Collection Dates <p>+----------------+-------------+------------+ | Collection     | Start Date  | End Date   | +----------------+-------------+------------+ | Level 2.2      | 2014-08-04  | present    | +----------------+-------------+------------+</p> Band Information <p>+-----------+---------+------------+-------------------------------------------+ | Band Name | Type    | Resolution | Description                               | +-----------+---------+------------+-------------------------------------------+ | hh        | L-band  | ~25 m      | Horizontal transmit and receive           | | hv        | L-band  | ~25 m      | Horizontal transmit, vertical receive     | | msk       | Bitmask | ~25 m      | MSK quality band (used only if enabled)   | +-----------+---------+------------+-------------------------------------------+</p> Notes <ul> <li> <p>Earth Engine Dataset:     https://developers.google.com/earth-engine/datasets/catalog/JAXA_ALOS_PALSAR-2_Level2_2_ScanSAR</p> </li> <li> <p>MSK Quality Mask Details (bit pattern):     https://www.eorc.jaxa.jp/ALOS/en/palsar_fnf/data/Format_PALSAR-2.html</p> </li> </ul> Source code in <code>agrigee_lite/sat/palsar.py</code> <pre><code>class PALSAR2ScanSAR(RadarSatellite):\n    \"\"\"\n    Satellite abstraction for ALOS PALSAR-2 ScanSAR (Level 2.2).\n\n    PALSAR-2 is an L-band Synthetic Aperture Radar (SAR) sensor onboard the ALOS-2 satellite,\n    operated by JAXA. This class provides preprocessing and abstraction for the Level 2.2\n    ScanSAR data product with 25-meter resolution. Optionally applies the MSK quality mask.\n\n    Parameters\n    ----------\n    bands : set of str, optional\n        Set of bands to select. Defaults to ['hh', 'hv'].\n    indices : set of str, optional\n        Radar indices to compute (e.g., polarization ratios). Defaults to [].\n    use_quality_mask : bool, default=True\n        Whether to apply the MSK bitmask quality filter. If False, all pixels are retained,\n        including those marked as low-quality or invalid.\n    min_valid_pixel_count : int, default=20\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=35_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Quality Masking\n    ---------------\n    When `use_quality_mask=True`, the `MSK` band is used to filter out invalid pixels.\n    The first 3 bits of the `MSK` band indicate data quality:\n        - 1 \u2192 Valid\n        - 5 \u2192 Invalid\n    Only pixels with value 1 are retained.\n\n    Satellite Information\n    ---------------------\n    +----------------------------+-------------------------------+\n    | Field                      | Value                         |\n    +----------------------------+-------------------------------+\n    | Name                       | ALOS PALSAR-2 ScanSAR         |\n    | Sensor                     | PALSAR-2 (L-band SAR)         |\n    | Platform                   | ALOS-2                        |\n    | Revisit Time               | ~14 days                      |\n    | Pixel Size                 | ~25 meters                    |\n    | Coverage                   | Japan + selected global areas |\n    +----------------------------+-------------------------------+\n\n    Collection Dates\n    ----------------\n    +----------------+-------------+------------+\n    | Collection     | Start Date  | End Date   |\n    +----------------+-------------+------------+\n    | Level 2.2      | 2014-08-04  | present    |\n    +----------------+-------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+---------+------------+-------------------------------------------+\n    | Band Name | Type    | Resolution | Description                               |\n    +-----------+---------+------------+-------------------------------------------+\n    | hh        | L-band  | ~25 m      | Horizontal transmit and receive           |\n    | hv        | L-band  | ~25 m      | Horizontal transmit, vertical receive     |\n    | msk       | Bitmask | ~25 m      | MSK quality band (used only if enabled)   |\n    +-----------+---------+------------+-------------------------------------------+\n\n    Notes\n    -----\n    - Earth Engine Dataset:\n        https://developers.google.com/earth-engine/datasets/catalog/JAXA_ALOS_PALSAR-2_Level2_2_ScanSAR\n\n    - MSK Quality Mask Details (bit pattern):\n        https://www.eorc.jaxa.jp/ALOS/en/palsar_fnf/data/Format_PALSAR-2.html\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        use_quality_mask: bool = True,\n        min_valid_pixel_count: int = 20,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 35000,\n    ):\n        bands = sorted({\"hh\", \"hv\"}) if bands is None else sorted(bands)\n\n        indices = [] if indices is None else sorted(indices)\n\n        super().__init__()\n\n        self.imageCollectionName: str = \"JAXA/ALOS/PALSAR-2/Level2_2/ScanSAR\"\n        self.pixelSize: int = 25\n        self.startDate: str = \"2014-08-04\"\n        self.endDate: str = \"2050-01-01\"\n        self.shortName: str = \"palsar2\"\n\n        self.availableBands: dict[str, str] = {\"hh\": \"HH\", \"hv\": \"HV\"}\n\n        self.selectedBands: list[tuple[str, str]] = [(band, f\"{(n + 10):02}_{band}\") for n, band in enumerate(bands)]\n\n        self.selectedIndices: list[str] = [\n            (self.availableIndices[indice_name], indice_name, f\"{(n + 40):02}_{indice_name}\")\n            for n, indice_name in enumerate(indices)\n        ]\n\n        self.use_quality_mask = use_quality_mask\n        self.minValidPixelCount = min_valid_pixel_count\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n\n        self.toDownloadSelectors = [numeral_band_name for _, numeral_band_name in self.selectedBands] + [\n            numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices\n        ]\n\n    @staticmethod\n    def _mask_quality(img: ee.Image) -&gt; ee.Image:\n        \"\"\"\n        Apply MSK quality mask to exclude invalid data.\n\n        MSK bits 0-2 indicate data quality:\n            1 = valid data\n            5 = invalid\n\n        Parameters\n        ----------\n        img : ee.Image\n\n        Returns\n        -------\n        ee.Image\n        \"\"\"\n        mask = img.select(\"MSK\")\n        quality = mask.bitwiseAnd(0b111)\n        valid = quality.eq(1)\n        return img.updateMask(valid)\n\n    def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n        ee_geometry = ee_feature.geometry()\n        ee_start = ee_feature.get(\"s\")\n        ee_end = ee_feature.get(\"e\")\n\n        ee_filter = ee.Filter.And(ee.Filter.bounds(ee_geometry), ee.Filter.date(ee_start, ee_end))\n\n        palsar_img = ee.ImageCollection(self.imageCollectionName).filter(ee_filter)\n\n        if self.use_quality_mask:\n            palsar_img = palsar_img.map(self._mask_quality)\n\n        palsar_img = palsar_img.select(\n            [self.availableBands[b] for b, _ in self.selectedBands], [b for b, _ in self.selectedBands]\n        )\n\n        palsar_img = palsar_img.map(\n            lambda img: ee.Image(img).addBands(ee.Image(img).pow(2).log10().multiply(10).subtract(83), overwrite=True)\n        )\n\n        if self.selectedIndices:\n            palsar_img = palsar_img.map(\n                partial(ee_add_indexes_to_image, indexes=[expression for (expression, _, _) in self.selectedIndices])\n            )\n\n        palsar_img = palsar_img.select(\n            [natural_band_name for natural_band_name, _ in self.selectedBands]\n            + [indice_name for _, indice_name, _ in self.selectedIndices],\n            [numeral_band_name for _, numeral_band_name in self.selectedBands]\n            + [numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices],\n        )\n\n        palsar_img = ee_filter_img_collection_invalid_pixels(palsar_img, ee_geometry, self.pixelSize, 20)\n\n        return palsar_img\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        palsar_img = self.imageCollection(ee_feature)\n\n        features = palsar_img.map(\n            partial(\n                ee_map_bands_and_doy,\n                ee_feature=ee_feature,\n                pixel_size=self.pixelSize,\n                subsampling_max_pixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n                reducer=ee_get_reducers(reducers),\n            )\n        )\n\n        return features\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.PALSAR2ScanSAR._mask_quality","title":"<code>_mask_quality(img)</code>  <code>staticmethod</code>","text":"<p>Apply MSK quality mask to exclude invalid data.</p> <p>MSK bits 0-2 indicate data quality:     1 = valid data     5 = invalid</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>Image</code> required <p>Returns:</p> Type Description <code>Image</code> Source code in <code>agrigee_lite/sat/palsar.py</code> <pre><code>@staticmethod\ndef _mask_quality(img: ee.Image) -&gt; ee.Image:\n    \"\"\"\n    Apply MSK quality mask to exclude invalid data.\n\n    MSK bits 0-2 indicate data quality:\n        1 = valid data\n        5 = invalid\n\n    Parameters\n    ----------\n    img : ee.Image\n\n    Returns\n    -------\n    ee.Image\n    \"\"\"\n    mask = img.select(\"MSK\")\n    quality = mask.bitwiseAnd(0b111)\n    valid = quality.eq(1)\n    return img.updateMask(valid)\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.SatelliteEmbedding","title":"<code>SatelliteEmbedding</code>","text":"<p>               Bases: <code>DataSourceSatellite</code></p> <p>Satellite abstraction for the Google Satellite Embedding collection.</p> <p>This collection contains annual, manually curated embeddings derived from multi-sensor satellite data.</p> <p>IMPORTANT: It always returns the center point value as the median (in order to maintain z-sphere normalization) and the standard deviation of the geometry without the borders.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>list of str</code> <p>List of bands to select. Defaults to all 64 embeddings.</p> <code>None</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-eroded) pixels required to retain an image.</p> <code>1</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>35_000</code> Satellite Information <p>+-----------------------------+-----------------------+ | Field                       | Value                 | +-----------------------------+-----------------------+ | Name                        | Satellite Embedding   | | Embedding Dimensions        | 64 (A0 to A63)        | | Pixel Size                  | ~10 meters            | | Temporal Resolution         | Annual                | | Coverage                    | Global                | +-----------------------------+-----------------------+</p> Collection Dates <p>+------------+------------+ | Start Date | End Date   | +------------+------------+ | 2017-01-01 | 2024-01-02 | +------------+------------+</p> Notes <p>Satellite Embedding V1:     - Dataset: https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_SATELLITE_EMBEDDING_V1_ANNUAL?hl=pt-br#bands</p> Source code in <code>agrigee_lite/sat/embeddings.py</code> <pre><code>class SatelliteEmbedding(DataSourceSatellite):\n    \"\"\"\n    Satellite abstraction for the Google Satellite Embedding collection.\n\n    This collection contains annual, manually curated embeddings derived from multi-sensor satellite data.\n\n    IMPORTANT: It always returns the center point value as the median (in order to maintain z-sphere normalization) and the standard deviation of the geometry without the borders.\n\n    Parameters\n    ----------\n    bands : list of str, optional\n        List of bands to select. Defaults to all 64 embeddings.\n    min_valid_pixel_count : int, default=1\n        Minimum number of valid (non-eroded) pixels required to retain an image.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=35_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Satellite Information\n    ---------------------\n    +-----------------------------+-----------------------+\n    | Field                       | Value                 |\n    +-----------------------------+-----------------------+\n    | Name                        | Satellite Embedding   |\n    | Embedding Dimensions        | 64 (A0 to A63)        |\n    | Pixel Size                  | ~10 meters            |\n    | Temporal Resolution         | Annual                |\n    | Coverage                    | Global                |\n    +-----------------------------+-----------------------+\n\n    Collection Dates\n    ----------------\n    +------------+------------+\n    | Start Date | End Date   |\n    +------------+------------+\n    | 2017-01-01 | 2024-01-02 |\n    +------------+------------+\n\n    Notes\n    ----------------\n    Satellite Embedding V1:\n        - Dataset: https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_SATELLITE_EMBEDDING_V1_ANNUAL?hl=pt-br#bands\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: list[str] | None = None,\n        min_valid_pixel_count: int = 1,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 35000,\n    ):\n        super().__init__()\n\n        if bands is None:\n            bands = [f\"A{i:02}\" for i in range(64)]\n\n        self.imageCollectionName: str = \"GOOGLE/SATELLITE_EMBEDDING/V1/ANNUAL\"\n        self.pixelSize: int = 10\n        self.startDate: str = \"2017-01-01\"\n        self.endDate: str = \"2024-01-01\"\n        self.shortName: str = \"satembed\"\n\n        self.availableBands: dict[str, str] = {b: b for b in bands}\n        self.selectedBands: list[tuple[str, str]] = [(band, f\"{(n + 10):02}_{band}\") for n, band in enumerate(bands)]\n\n        self.minValidPixelCount = min_valid_pixel_count\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n\n    def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n        ee_geometry = ee_feature.geometry()\n        ee_start = ee_feature.get(\"s\")\n        ee_end = ee_feature.get(\"e\")\n\n        ee_filter = ee.Filter.And(\n            ee.Filter.bounds(ee_geometry),\n            ee.Filter.date(ee_start, ee_end),\n        )\n\n        imgcol = (\n            ee.ImageCollection(self.imageCollectionName)\n            .filter(ee_filter)\n            .select(\n                list(self.availableBands.values()),\n                list(self.availableBands.keys()),\n            )\n        )\n\n        imgcol = imgcol.select(\n            [natural for natural, _ in self.selectedBands],\n            [renamed for _, renamed in self.selectedBands],\n        )\n\n        imgcol = ee_filter_img_collection_invalid_pixels(imgcol, ee_geometry, self.pixelSize, self.minValidPixelCount)\n\n        return imgcol\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        imgcol = self.imageCollection(ee_feature)\n\n        def compute_stats(\n            ee_img: ee.Image, ee_feature: ee.Feature, pixel_size: int, subsampling_max_pixels: ee.Number\n        ) -&gt; ee.Feature:\n            ee_img = ee.Image(ee_img)\n\n            median = ee_img.reduceRegion(\n                reducer=ee.Reducer.first(),\n                geometry=ee_feature.geometry().centroid(0.001),\n                scale=pixel_size,\n                maxPixels=subsampling_max_pixels,\n                bestEffort=True,\n            )\n\n            stddev = ee_img.reduceRegion(\n                reducer=ee.Reducer.stdDev(),\n                geometry=ee_geometry,\n                scale=pixel_size,\n                maxPixels=subsampling_max_pixels,\n                bestEffort=True,\n            )\n\n            stddev = stddev.rename(stddev.keys(), stddev.keys().map(lambda k: ee.String(k).cat(\"_stdDev\")), True)\n            median = median.rename(median.keys(), median.keys().map(lambda k: ee.String(k).cat(\"_median\")), True)\n\n            props = ee.Dictionary(median).combine(stddev)\n\n            props = props.set(\"00_indexnum\", ee_feature.get(\"0\"))\n            props = props.set(\"01_timestamp\", ee.Date(ee_img.date()).format(\"YYYY-MM-dd\"))\n            props = props.set(\"99_validPixelsCount\", ee_img.get(\"ZZ_USER_VALID_PIXELS\"))\n\n            return ee.Feature(None, props)\n\n        features = imgcol.map(\n            partial(\n                compute_stats,\n                ee_feature=ee_feature,\n                pixel_size=self.pixelSize,\n                subsampling_max_pixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n            )\n        )\n\n        return ee.FeatureCollection(features)\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Sentinel1GRD","title":"<code>Sentinel1GRD</code>","text":"<p>               Bases: <code>RadarSatellite</code></p> \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f Sentinel-1 Availability Warning <p>Due to the failure of the Sentinel-1B satellite in December 2021, the constellation has been operating solely with Sentinel-1A. This has led to reduced data availability in many regions \u2014 particularly in the Southern Hemisphere \u2014 with revisit times increasing from ~6 days to ~12 days or more. Some areas may experience significant temporal gaps, especially after early 2022. \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f</p> <p>Satellite abstraction for Sentinel-1 Ground Range Detected (GRD) product.</p> <p>Sentinel-1 is a constellation of two polar-orbiting satellites (Sentinel-1A and 1B) operated by ESA, equipped with C-band Synthetic Aperture Radar (SAR). It provides all-weather, day-and-night imaging of Earth's surface.</p> <p>This class wraps the Sentinel-1 GRD product and allows users to select polarizations, filter by orbit pass, and apply edge masks to remove low-backscatter areas (e.g., layover).</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>set of str</code> <p>Set of polarizations to select. Defaults to {'vv', 'vh'}.</p> <code>None</code> <code>indices</code> <code>set of str</code> <p>Set of radar indices (e.g. ratios). Defaults to [].</p> <code>None</code> <code>ascending</code> <code>bool</code> <p>If True, selects ASCENDING orbit passes. If False, selects DESCENDING.</p> <code>True</code> <code>use_edge_mask</code> <code>bool</code> <p>Whether to apply an edge mask to remove extreme low-backscatter areas (commonly occurring near the edges of acquisitions or in layover/shadow zones). Default is True.</p> <code>True</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>20</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>35_000</code> Edge Masking <p>Sentinel-1 radar images often contain low-backscatter areas near image borders or over layover zones. This class applies a threshold-based edge mask (<code>&lt; -30 dB</code>) to reduce artifacts.</p> Satellite Information <p>+-------------------------------+-------------------------------+ | Field                         | Value                         | +-------------------------------+-------------------------------+ | Name                          | Sentinel-1                    | | Agency                        | ESA (Copernicus)              | | Instrument                    | C-band Synthetic Aperture Radar (SAR) | | Revisit Time (full mission)   | ~6 days (1A + 1B constellation)| | Revisit Time (post-2021)      | ~12 days (only 1A active)     | | Orbit Type                    | Sun-synchronous (polar)       | | Pixel Size                    | ~10 meters                    | | Coverage                      | Global                        | +-------------------------------+-------------------------------+</p> Collection Dates <p>+------------------+-------------+-----------+ | Product          | Start Date  | End Date  | +------------------+-------------+-----------+ | GRD              | 2014-10-03  | present   | +------------------+-------------+-----------+</p> Band Information <p>+------------+-----------+-------------+------------------------------+ | Band Name  | Frequency | Resolution  | Description                  | +------------+-----------+-------------+------------------------------+ | VV         | 5.405 GHz | ~10 meters  | Vertical transmit/receive    | | VH         | 5.405 GHz | ~10 meters  | Vertical transmit, horizontal receive | +------------+-----------+-------------+------------------------------+</p> Notes <ul> <li> <p>Official GRD collection (Earth Engine):   https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S1_GRD</p> </li> <li> <p>Sentinel-1 User Guide:   https://sentinels.copernicus.eu/web/sentinel/user-guides/sentinel-1-sar</p> </li> <li> <p>Orbit direction filter:   https://developers.google.com/earth-engine/sentinel1#orbit-direction</p> </li> </ul> Source code in <code>agrigee_lite/sat/sentinel1.py</code> <pre><code>class Sentinel1GRD(RadarSatellite):\n    \"\"\"\n    \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f Sentinel-1 Availability Warning\n    ---------------------------------\n    Due to the failure of the Sentinel-1B satellite in December 2021, the constellation has been operating solely\n    with Sentinel-1A. This has led to reduced data availability in many regions \u2014 particularly in the Southern\n    Hemisphere \u2014 with revisit times increasing from ~6 days to ~12 days or more. Some areas may experience\n    significant temporal gaps, especially after early 2022. \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f\n\n    Satellite abstraction for Sentinel-1 Ground Range Detected (GRD) product.\n\n    Sentinel-1 is a constellation of two polar-orbiting satellites (Sentinel-1A and 1B)\n    operated by ESA, equipped with C-band Synthetic Aperture Radar (SAR). It provides\n    all-weather, day-and-night imaging of Earth's surface.\n\n    This class wraps the Sentinel-1 GRD product and allows users to select polarizations,\n    filter by orbit pass, and apply edge masks to remove low-backscatter areas (e.g., layover).\n\n    Parameters\n    ----------\n    bands : set of str, optional\n        Set of polarizations to select. Defaults to {'vv', 'vh'}.\n    indices : set of str, optional\n        Set of radar indices (e.g. ratios). Defaults to [].\n    ascending : bool, default=True\n        If True, selects ASCENDING orbit passes. If False, selects DESCENDING.\n    use_edge_mask : bool, optional\n        Whether to apply an edge mask to remove extreme low-backscatter areas\n        (commonly occurring near the edges of acquisitions or in layover/shadow zones).\n        Default is True.\n    min_valid_pixel_count : int, default=20\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=35_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Edge Masking\n    ------------\n    Sentinel-1 radar images often contain low-backscatter areas near image borders or over layover zones.\n    This class applies a threshold-based edge mask (`&lt; -30 dB`) to reduce artifacts.\n\n    Satellite Information\n    ---------------------\n    +-------------------------------+-------------------------------+\n    | Field                         | Value                         |\n    +-------------------------------+-------------------------------+\n    | Name                          | Sentinel-1                    |\n    | Agency                        | ESA (Copernicus)              |\n    | Instrument                    | C-band Synthetic Aperture Radar (SAR) |\n    | Revisit Time (full mission)   | ~6 days (1A + 1B constellation)|\n    | Revisit Time (post-2021)      | ~12 days (only 1A active)     |\n    | Orbit Type                    | Sun-synchronous (polar)       |\n    | Pixel Size                    | ~10 meters                    |\n    | Coverage                      | Global                        |\n    +-------------------------------+-------------------------------+\n\n    Collection Dates\n    ----------------\n    +------------------+-------------+-----------+\n    | Product          | Start Date  | End Date  |\n    +------------------+-------------+-----------+\n    | GRD              | 2014-10-03  | present   |\n    +------------------+-------------+-----------+\n\n    Band Information\n    ----------------\n    +------------+-----------+-------------+------------------------------+\n    | Band Name  | Frequency | Resolution  | Description                  |\n    +------------+-----------+-------------+------------------------------+\n    | VV         | 5.405 GHz | ~10 meters  | Vertical transmit/receive    |\n    | VH         | 5.405 GHz | ~10 meters  | Vertical transmit, horizontal receive |\n    +------------+-----------+-------------+------------------------------+\n\n    Notes\n    -----\n    - Official GRD collection (Earth Engine):\n      https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S1_GRD\n\n    - Sentinel-1 User Guide:\n      https://sentinels.copernicus.eu/web/sentinel/user-guides/sentinel-1-sar\n\n    - Orbit direction filter:\n      https://developers.google.com/earth-engine/sentinel1#orbit-direction\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        ascending: bool = True,\n        use_edge_mask: bool = True,\n        min_valid_pixel_count: int = 20,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 35000,\n    ):\n        bands = sorted({\"vv\", \"vh\"}) if bands is None else sorted(bands)\n\n        indices = [] if indices is None else sorted(indices)\n\n        super().__init__()\n\n        self.ascending: bool = ascending\n        self.use_edge_mask: bool = use_edge_mask\n        self.minValidPixelCount = min_valid_pixel_count\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n        self.imageCollectionName: str = \"COPERNICUS/S1_GRD\"\n        self.pixelSize: int = 10\n\n        # full mission start (S-1A launch)\n        self.startDate: str = \"2014-10-03\"\n        self.endDate: str = \"2050-01-01\"\n        self.shortName: str = \"s1a\" if ascending else \"s1d\"\n\n        # original \u2192 product band\n        self.availableBands: dict[str, str] = {\"vv\": \"VV\", \"vh\": \"VH\"}\n\n        self.selectedBands: list[tuple[str, str]] = [(band, f\"{(n + 10):02}_{band}\") for n, band in enumerate(bands)]\n\n        self.selectedIndices: list[str] = [\n            (self.availableIndices[indice_name], indice_name, f\"{(n + 40):02}_{indice_name}\")\n            for n, indice_name in enumerate(indices)\n        ]\n\n        self.toDownloadSelectors = [numeral_band_name for _, numeral_band_name in self.selectedBands] + [\n            numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices\n        ]\n\n    @staticmethod\n    def _mask_edge(img: ee.Image) -&gt; ee.Image:\n        \"\"\"\n        Remove extreme low-backscatter areas (edges / layover)\n\n        Parameters\n        ----------\n        img : ee.Image\n            Unfiltered Sentinel-1 image\n\n        Returns\n        -------\n        ee.Image\n            Filtered Sentinel-1 image\n        \"\"\"\n\n        edge = img.lt(-30.0)\n        valid = img.mask().And(edge.Not())\n        return img.updateMask(valid)\n\n    def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n        ee_geometry = ee_feature.geometry()\n        ee_start = ee_feature.get(\"s\")\n        ee_end = ee_feature.get(\"e\")\n\n        ee_filter = ee.Filter.And(ee.Filter.bounds(ee_geometry), ee.Filter.date(ee_start, ee_end))\n\n        polarization_filter = ee.Filter.And(*[\n            ee.Filter.listContains(\"transmitterReceiverPolarisation\", self.availableBands[b])\n            for b, _ in self.selectedBands\n        ])\n\n        orbit_filter = ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\" if self.ascending else \"DESCENDING\")\n\n        s1_img = (\n            ee.ImageCollection(self.imageCollectionName)\n            .filter(ee_filter)\n            .filter(polarization_filter)\n            .filter(orbit_filter)\n        )\n\n        if self.use_edge_mask:\n            s1_img = s1_img.map(self._mask_edge)\n\n        s1_img = s1_img.select(list(self.availableBands.values()), list(self.availableBands.keys()))\n\n        if self.selectedIndices:\n            s1_img = s1_img.map(\n                partial(ee_add_indexes_to_image, indexes=[expression for (expression, _, _) in self.selectedIndices])\n            )\n\n        s1_img = s1_img.select(\n            [natural_band_name for natural_band_name, _ in self.selectedBands]\n            + [indice_name for _, indice_name, _ in self.selectedIndices],\n            [numeral_band_name for _, numeral_band_name in self.selectedBands]\n            + [numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices],\n        )\n\n        s1_img = ee_filter_img_collection_invalid_pixels(s1_img, ee_geometry, self.pixelSize, self.minValidPixelCount)\n\n        return ee.ImageCollection(s1_img)\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        s1_img = self.imageCollection(ee_feature)\n\n        features = s1_img.map(\n            partial(\n                ee_map_bands_and_doy,\n                ee_feature=ee_feature,\n                pixel_size=self.pixelSize,\n                subsampling_max_pixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n                reducer=ee_get_reducers(reducers),\n            )\n        )\n\n        return features\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Sentinel1GRD._mask_edge","title":"<code>_mask_edge(img)</code>  <code>staticmethod</code>","text":"<p>Remove extreme low-backscatter areas (edges / layover)</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>Image</code> <p>Unfiltered Sentinel-1 image</p> required <p>Returns:</p> Type Description <code>Image</code> <p>Filtered Sentinel-1 image</p> Source code in <code>agrigee_lite/sat/sentinel1.py</code> <pre><code>@staticmethod\ndef _mask_edge(img: ee.Image) -&gt; ee.Image:\n    \"\"\"\n    Remove extreme low-backscatter areas (edges / layover)\n\n    Parameters\n    ----------\n    img : ee.Image\n        Unfiltered Sentinel-1 image\n\n    Returns\n    -------\n    ee.Image\n        Filtered Sentinel-1 image\n    \"\"\"\n\n    edge = img.lt(-30.0)\n    valid = img.mask().And(edge.Not())\n    return img.updateMask(valid)\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.Sentinel2","title":"<code>Sentinel2</code>","text":"<p>               Bases: <code>OpticalSatellite</code></p> <p>Satellite abstraction for Sentinel-2 (HARMONIZED collections).</p> <p>Sentinel-2 is a constellation of twin Earth observation satellites, operated by ESA, designed for land monitoring, vegetation, soil, water cover, and coastal areas.</p> <p>Parameters:</p> Name Type Description Default <code>bands</code> <code>list of str</code> <p>List of bands to select. Defaults to all 10 bands most used for vegetation and soil analysis.</p> <code>None</code> <code>indices</code> <code>list of str</code> <p>List of spectral indices to compute from the selected bands.</p> <code>None</code> <code>use_sr</code> <code>bool</code> <p>If True, uses surface reflectance (BOA, 'S2_SR_HARMONIZED'). If False, uses top-of-atmosphere reflectance ('S2_HARMONIZED').</p> <code>True</code> <code>cloud_probability_threshold</code> <code>float</code> <p>Minimum threshold to consider a pixel as cloud-free.</p> <code>0.7</code> <code>min_valid_pixel_count</code> <code>int</code> <p>Minimum number of valid (non-cloud) pixels required to retain an image.</p> <code>20</code> <code>border_pixels_to_erode</code> <code>float</code> <p>Number of pixels to erode from the geometry border.</p> <code>1</code> <code>min_area_to_keep_border</code> <code>int</code> <p>Minimum area (in m\u00b2) required to retain geometry after border erosion.</p> <code>35_000</code> Satellite Information <p>+------------------------------------+------------------------+ | Field                              | Value                  | +------------------------------------+------------------------+ | Name                               | Sentinel-2             | | Revisit Time                       | 5 days                 | | Revisit Time (cloud-free estimate) | ~7 days                | | Pixel Size                         | 10 meters              | | Coverage                           | Global                 | +------------------------------------+------------------------+</p> Collection Dates <p>+----------------------------+------------+------------+ | Collection Type            | Start Date | End Date  | +----------------------------+------------+------------+ | TOA (Top of Atmosphere)    | 2016-01-01 | present   | | SR (Surface Reflectance)   | 2019-01-01 | present   | +----------------------------+------------+------------+</p> Band Information <p>+-----------+---------------+--------------+------------------------+ | Band Name | Original Band | Resolution   | Spectral Wavelength    | +-----------+---------------+--------------+------------------------+ | blue      | B2            | 10 m         | 492 nm                 | | green     | B3            | 10 m         | 559 nm                 | | red       | B4            | 10 m         | 665 nm                 | | re1       | B5            | 20 m         | 704 nm                 | | re2       | B6            | 20 m         | 739 nm                 | | re3       | B7            | 20 m         | 780 nm                 | | nir       | B8            | 10 m         | 833 nm                 | | re4       | B8A           | 20 m         | 864 nm                 | | swir1     | B11           | 20 m         | 1610 nm                | | swir2     | B12           | 20 m         | 2186 nm                | +-----------+---------------+--------------+------------------------+</p> Notes <p>Cloud Masking:     This class uses the Cloud Score Plus dataset to estimate cloud probability:     https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_CLOUD_SCORE_PLUS_V1_S2_HARMONIZED</p> <p>Sentinel-2 Collections:     - TOA: https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_HARMONIZED     - SR:  https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR_HARMONIZED</p> Source code in <code>agrigee_lite/sat/sentinel2.py</code> <pre><code>class Sentinel2(OpticalSatellite):\n    \"\"\"\n    Satellite abstraction for Sentinel-2 (HARMONIZED collections).\n\n    Sentinel-2 is a constellation of twin Earth observation satellites,\n    operated by ESA, designed for land monitoring, vegetation, soil, water cover, and coastal areas.\n\n    Parameters\n    ----------\n    bands : list of str, optional\n        List of bands to select. Defaults to all 10 bands most used for vegetation and soil analysis.\n    indices : list of str, optional\n        List of spectral indices to compute from the selected bands.\n    use_sr : bool, default=True\n        If True, uses surface reflectance (BOA, 'S2_SR_HARMONIZED').\n        If False, uses top-of-atmosphere reflectance ('S2_HARMONIZED').\n    cloud_probability_threshold : float, default=0.7\n        Minimum threshold to consider a pixel as cloud-free.\n    min_valid_pixel_count : int, default=20\n        Minimum number of valid (non-cloud) pixels required to retain an image.\n    border_pixels_to_erode : float, default=1\n        Number of pixels to erode from the geometry border.\n    min_area_to_keep_border : int, default=35_000\n        Minimum area (in m\u00b2) required to retain geometry after border erosion.\n\n    Satellite Information\n    ---------------------\n    +------------------------------------+------------------------+\n    | Field                              | Value                  |\n    +------------------------------------+------------------------+\n    | Name                               | Sentinel-2             |\n    | Revisit Time                       | 5 days                 |\n    | Revisit Time (cloud-free estimate) | ~7 days                |\n    | Pixel Size                         | 10 meters              |\n    | Coverage                           | Global                 |\n    +------------------------------------+------------------------+\n\n    Collection Dates\n    ----------------\n    +----------------------------+------------+------------+\n    | Collection Type            | Start Date | End Date  |\n    +----------------------------+------------+------------+\n    | TOA (Top of Atmosphere)    | 2016-01-01 | present   |\n    | SR (Surface Reflectance)   | 2019-01-01 | present   |\n    +----------------------------+------------+------------+\n\n    Band Information\n    ----------------\n    +-----------+---------------+--------------+------------------------+\n    | Band Name | Original Band | Resolution   | Spectral Wavelength    |\n    +-----------+---------------+--------------+------------------------+\n    | blue      | B2            | 10 m         | 492 nm                 |\n    | green     | B3            | 10 m         | 559 nm                 |\n    | red       | B4            | 10 m         | 665 nm                 |\n    | re1       | B5            | 20 m         | 704 nm                 |\n    | re2       | B6            | 20 m         | 739 nm                 |\n    | re3       | B7            | 20 m         | 780 nm                 |\n    | nir       | B8            | 10 m         | 833 nm                 |\n    | re4       | B8A           | 20 m         | 864 nm                 |\n    | swir1     | B11           | 20 m         | 1610 nm                |\n    | swir2     | B12           | 20 m         | 2186 nm                |\n    +-----------+---------------+--------------+------------------------+\n\n    Notes\n    ----------------\n    Cloud Masking:\n        This class uses the **Cloud Score Plus** dataset to estimate cloud probability:\n        https://developers.google.com/earth-engine/datasets/catalog/GOOGLE_CLOUD_SCORE_PLUS_V1_S2_HARMONIZED\n\n    Sentinel-2 Collections:\n        - TOA: https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_HARMONIZED\n        - SR:  https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_SR_HARMONIZED\n    \"\"\"\n\n    def __init__(\n        self,\n        bands: set[str] | None = None,\n        indices: set[str] | None = None,\n        use_sr: bool = True,\n        cloud_probability_threshold: float = 0.7,\n        min_valid_pixel_count: int = 20,\n        border_pixels_to_erode: float = 1,\n        min_area_to_keep_border: int = 35000,\n    ):\n        bands = (\n            sorted({\"blue\", \"green\", \"red\", \"re1\", \"re2\", \"re3\", \"nir\", \"re4\", \"swir1\", \"swir2\"})\n            if bands is None\n            else sorted(bands)\n        )\n\n        indices = [] if indices is None else sorted(indices)\n\n        super().__init__()\n        self.useSr = use_sr\n        self.imageCollectionName = \"COPERNICUS/S2_SR_HARMONIZED\" if use_sr else \"COPERNICUS/S2_HARMONIZED\"\n        self.pixelSize: int = 10\n\n        self.startDate: str = \"2019-01-01\" if use_sr else \"2016-01-01\"\n        self.endDate: str = \"2050-01-01\"\n        self.shortName: str = \"s2sr\" if use_sr else \"s2\"\n\n        self.availableBands: dict[str, str] = {\n            \"blue\": \"B2\",\n            \"green\": \"B3\",\n            \"red\": \"B4\",\n            \"re1\": \"B5\",\n            \"re2\": \"B6\",\n            \"re3\": \"B7\",\n            \"nir\": \"B8\",\n            \"re4\": \"B8A\",\n            \"swir1\": \"B11\",\n            \"swir2\": \"B12\",\n        }\n\n        self.selectedBands: list[tuple[str, str]] = [(band, f\"{(n + 10):02}_{band}\") for n, band in enumerate(bands)]\n\n        self.selectedIndices: list[str] = [\n            (self.availableIndices[indice_name], indice_name, f\"{(n + 40):02}_{indice_name}\")\n            for n, indice_name in enumerate(indices)\n        ]\n\n        self.cloudProbabilityThreshold = cloud_probability_threshold\n        self.minValidPixelCount = min_valid_pixel_count\n        self.minAreaToKeepBorder = min_area_to_keep_border\n        self.borderPixelsToErode = border_pixels_to_erode\n\n        self.toDownloadSelectors = [numeral_band_name for _, numeral_band_name in self.selectedBands] + [\n            numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices\n        ]\n\n    def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n        ee_geometry = ee_feature.geometry()\n\n        ee_start_date = ee_feature.get(\"s\")\n        ee_end_date = ee_feature.get(\"e\")\n\n        ee_filter = ee.Filter.And(ee.Filter.bounds(ee_geometry), ee.Filter.date(ee_start_date, ee_end_date))\n\n        s2_img = (\n            ee.ImageCollection(self.imageCollectionName)\n            .filter(ee_filter)\n            .select(\n                list(self.availableBands.values()),\n                list(self.availableBands.keys()),\n            )\n        )\n\n        s2_img = s2_img.map(lambda img: ee.Image(img).addBands(ee.Image(img).divide(10000), overwrite=True))\n\n        if self.selectedIndices:\n            s2_img = s2_img.map(\n                partial(ee_add_indexes_to_image, indexes=[expression for (expression, _, _) in self.selectedIndices])\n            )\n\n        s2_img = s2_img.select(\n            [natural_band_name for natural_band_name, _ in self.selectedBands]\n            + [indice_name for _, indice_name, _ in self.selectedIndices],\n            [numeral_band_name for _, numeral_band_name in self.selectedBands]\n            + [numeral_indice_name for _, _, numeral_indice_name in self.selectedIndices],\n        )\n\n        s2_cloud_mask = (\n            ee.ImageCollection(\"GOOGLE/CLOUD_SCORE_PLUS/V1/S2_HARMONIZED\")\n            .filter(ee_filter)\n            .select([\"cs_cdf\"], [\"cloud\"])\n        )\n\n        s2_img = s2_img.combine(s2_cloud_mask)\n\n        s2_img = s2_img.map(lambda img: ee_cloud_probability_mask(img, self.cloudProbabilityThreshold, True))\n        s2_img = ee_filter_img_collection_invalid_pixels(s2_img, ee_geometry, self.pixelSize, self.minValidPixelCount)\n\n        return ee.ImageCollection(s2_img)\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n\n        if self.borderPixelsToErode != 0:\n            ee_geometry = ee_safe_remove_borders(\n                ee_geometry, round(self.borderPixelsToErode * self.pixelSize), self.minAreaToKeepBorder\n            )\n            ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        s2_img = self.imageCollection(ee_feature)\n\n        features = s2_img.map(\n            partial(\n                ee_map_bands_and_doy,\n                ee_feature=ee_feature,\n                pixel_size=self.pixelSize,\n                subsampling_max_pixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n                reducer=ee_get_reducers(reducers),\n            )\n        )\n\n        return features\n</code></pre>"},{"location":"modules/#agrigee_lite.sat.TwoSatelliteFusion","title":"<code>TwoSatelliteFusion</code>","text":"<p>               Bases: <code>OpticalSatellite</code></p> <p>A satellite fusion class that combines data from exactly two optical satellites for synchronized analysis.</p> <p>This class enables the fusion of data from two different optical satellites by finding common observation dates and merging their image collections. It ensures temporal alignment between the two satellite datasets, making it possible to perform comparative analysis or create composite datasets from dual satellite sources.</p> <p>The class is specifically designed for two-satellite fusion and automatically handles: - Temporal intersection calculation between the two satellite date ranges - Spatial resolution alignment using the finest available resolution - Band renaming with prefixes to distinguish between the two satellite sources - Image collection synchronization based on common observation dates - Unified processing pipeline for both satellite datasets</p> <p>Parameters:</p> Name Type Description Default <code>satellite_a</code> <code>OpticalSatellite</code> <p>The first optical satellite configuration object.</p> required <code>satellite_b</code> <code>OpticalSatellite</code> <p>The second optical satellite configuration object.</p> required <p>Attributes:</p> Name Type Description <code>sat_a</code> <code>OpticalSatellite</code> <p>Reference to the first satellite object.</p> <code>sat_b</code> <code>OpticalSatellite</code> <p>Reference to the second satellite object.</p> <code>startDate</code> <code>str</code> <p>The latest start date between both satellites (ISO format).</p> <code>endDate</code> <code>str</code> <p>The earliest end date between both satellites (ISO format).</p> <code>pixelSize</code> <code>float</code> <p>The finest spatial resolution between both satellites.</p> <code>shortName</code> <code>str</code> <p>Combined short name identifier for the fused satellite configuration.</p> <code>toDownloadSelectors</code> <code>list[str]</code> <p>Combined selectors from both satellites with distinguishing prefixes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from agrigee_lite.sat.landsat import Landsat8\n&gt;&gt;&gt; from agrigee_lite.sat.sentinel import Sentinel2\n&gt;&gt;&gt;\n&gt;&gt;&gt; l8 = Landsat8()\n&gt;&gt;&gt; s2 = Sentinel2()\n&gt;&gt;&gt; fusion = TwoSatelliteFusion(l8, s2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # The fused satellite will only cover the temporal overlap\n&gt;&gt;&gt; print(fusion.startDate)  # Latest of the two start dates\n&gt;&gt;&gt; print(fusion.endDate)    # Earliest of the two end dates\n</code></pre> Source code in <code>agrigee_lite/sat/unified_satellite.py</code> <pre><code>class TwoSatelliteFusion(OpticalSatellite):\n    \"\"\"\n    A satellite fusion class that combines data from exactly two optical satellites for synchronized analysis.\n\n    This class enables the fusion of data from two different optical satellites by finding\n    common observation dates and merging their image collections. It ensures temporal alignment\n    between the two satellite datasets, making it possible to perform comparative analysis or\n    create composite datasets from dual satellite sources.\n\n    The class is specifically designed for two-satellite fusion and automatically handles:\n    - Temporal intersection calculation between the two satellite date ranges\n    - Spatial resolution alignment using the finest available resolution\n    - Band renaming with prefixes to distinguish between the two satellite sources\n    - Image collection synchronization based on common observation dates\n    - Unified processing pipeline for both satellite datasets\n\n    Parameters\n    ----------\n    satellite_a : OpticalSatellite\n        The first optical satellite configuration object.\n    satellite_b : OpticalSatellite\n        The second optical satellite configuration object.\n\n    Attributes\n    ----------\n    sat_a : OpticalSatellite\n        Reference to the first satellite object.\n    sat_b : OpticalSatellite\n        Reference to the second satellite object.\n    startDate : str\n        The latest start date between both satellites (ISO format).\n    endDate : str\n        The earliest end date between both satellites (ISO format).\n    pixelSize : float\n        The finest spatial resolution between both satellites.\n    shortName : str\n        Combined short name identifier for the fused satellite configuration.\n    toDownloadSelectors : list[str]\n        Combined selectors from both satellites with distinguishing prefixes.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from agrigee_lite.sat.landsat import Landsat8\n    &gt;&gt;&gt; from agrigee_lite.sat.sentinel import Sentinel2\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; l8 = Landsat8()\n    &gt;&gt;&gt; s2 = Sentinel2()\n    &gt;&gt;&gt; fusion = TwoSatelliteFusion(l8, s2)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # The fused satellite will only cover the temporal overlap\n    &gt;&gt;&gt; print(fusion.startDate)  # Latest of the two start dates\n    &gt;&gt;&gt; print(fusion.endDate)    # Earliest of the two end dates\n    \"\"\"\n\n    def __init__(self, satellite_a: OpticalSatellite, satellite_b: OpticalSatellite):\n        super().__init__()\n        self.sat_a = satellite_a\n        self.sat_b = satellite_b\n\n        # Get the intersection between start date and end date of both satellites\n        self.startDate = max(\n            datetime.fromisoformat(satellite_a.startDate), datetime.fromisoformat(satellite_b.startDate)\n        ).isoformat()\n        self.endDate = min(\n            datetime.fromisoformat(satellite_a.endDate), datetime.fromisoformat(satellite_b.endDate)\n        ).isoformat()\n\n        self.pixelSize = min(satellite_a.pixelSize, satellite_b.pixelSize)\n        self.shortName = f\"fusion_{satellite_a.shortName}_{satellite_b.shortName}\"\n        self.toDownloadSelectors = [\n            f\"8{selector}{satellite_a.shortName}\" for selector in satellite_a.toDownloadSelectors\n        ] + [f\"7{selector}{satellite_b.shortName}\" for selector in satellite_b.toDownloadSelectors]\n\n    def imageCollection(self, ee_feature: ee.Feature) -&gt; ee.ImageCollection:\n        sat_a = self.sat_a.imageCollection(ee_feature)\n        sat_b = self.sat_b.imageCollection(ee_feature)\n\n        sat_a_dates = extract_dates(sat_a)\n        sat_b_dates = extract_dates(sat_b)\n\n        common_dates = intersect_lists(sat_a_dates, sat_b_dates)\n\n        sat_a_filtered = filter_by_common_dates(sat_a, common_dates)\n        sat_b_filtered = filter_by_common_dates(sat_b, common_dates)\n\n        sat_a_filtered = rename_bands(sat_a_filtered, \"8\", self.sat_a.shortName)\n        sat_b_filtered = rename_bands(sat_b_filtered, \"7\", self.sat_b.shortName)\n\n        merged = sat_a_filtered.linkCollection(\n            sat_b_filtered, matchPropertyName=\"ZZ_USER_TIME_DUMMY\", linkedBands=sat_b_filtered.first().bandNames()\n        )\n\n        return merged\n\n    def compute(\n        self,\n        ee_feature: ee.Feature,\n        subsampling_max_pixels: float,\n        reducers: set[str] | None = None,\n    ) -&gt; ee.FeatureCollection:\n        ee_geometry = ee_feature.geometry()\n        ee_geometry = ee_safe_remove_borders(ee_geometry, self.pixelSize, 35000)\n        ee_feature = ee_feature.setGeometry(ee_geometry)\n\n        s2_img = self.imageCollection(ee_feature)\n\n        features = s2_img.map(\n            partial(\n                ee_map_bands_and_doy,\n                ee_feature=ee_feature,\n                pixel_size=self.pixelSize,\n                subsampling_max_pixels=ee_get_number_of_pixels(ee_geometry, subsampling_max_pixels, self.pixelSize),\n                reducer=ee_get_reducers(reducers),\n            )\n        )\n\n        return features\n\n    def log_dict(self) -&gt; dict:\n        d = {}\n        d[\"sat_a\"] = self.sat_a.log_dict()\n        d[\"sat_b\"] = self.sat_b.log_dict()\n        return d\n</code></pre>"},{"location":"modules/#agrigee_lite.vis.multiple_sits","title":"<code>multiple_sits(gdf, satellite, band_or_indice_to_plot, reducer='median', ax=None, color='blue', alpha=0.5)</code>","text":"<p>Visualize satellite time series for multiple geometries with normalized temporal alignment.</p> <p>Creates overlaid line plots for multiple geometries, with time series normalized to year fractions to enable comparison across different years. Each geometry's time series is plotted as a semi-transparent line, making it easy to identify patterns and outliers across the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing multiple geometries and their temporal information. Must have the required date columns for satellite time series processing.</p> required <code>satellite</code> <code>AbstractSatellite</code> <p>Satellite configuration object.</p> required <code>band_or_indice_to_plot</code> <code>str</code> <p>Name of the band or vegetation index to visualize.</p> required <code>reducer</code> <code>str</code> <p>Temporal reducer to apply (e.g., \"median\", \"mean\"), by default \"median\".</p> <code>'median'</code> <code>ax</code> <code>Axes or None</code> <p>Matplotlib axes object for plotting. If None, creates a new plot, by default None.</p> <code>None</code> <code>color</code> <code>str</code> <p>Color for the plot lines, by default \"blue\".</p> <code>'blue'</code> <code>alpha</code> <code>float</code> <p>Transparency level for individual lines (0.0 to 1.0), by default 0.5. Lower values help visualize overlapping time series.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>None</code> <p>The function creates a plot but doesn't return any value.</p> Notes <p>This function normalizes timestamps to year fractions, where each time series starts from 0.0, making it possible to overlay multiple years of data for pattern analysis. The original timestamps are converted using the <code>year_fraction</code> function and then normalized to start from zero.</p> Source code in <code>agrigee_lite/vis/sits.py</code> <pre><code>def visualize_multiple_sits(\n    gdf: gpd.GeoDataFrame,\n    satellite: AbstractSatellite,\n    band_or_indice_to_plot: str,\n    reducer: str = \"median\",\n    ax: Any = None,\n    color: str = \"blue\",\n    alpha: float = 0.5,\n) -&gt; None:\n    \"\"\"\n    Visualize satellite time series for multiple geometries with normalized temporal alignment.\n\n    Creates overlaid line plots for multiple geometries, with time series normalized\n    to year fractions to enable comparison across different years. Each geometry's\n    time series is plotted as a semi-transparent line, making it easy to identify\n    patterns and outliers across the dataset.\n\n    Parameters\n    ----------\n    gdf : gpd.GeoDataFrame\n        GeoDataFrame containing multiple geometries and their temporal information.\n        Must have the required date columns for satellite time series processing.\n    satellite : AbstractSatellite\n        Satellite configuration object.\n    band_or_indice_to_plot : str\n        Name of the band or vegetation index to visualize.\n    reducer : str, optional\n        Temporal reducer to apply (e.g., \"median\", \"mean\"), by default \"median\".\n    ax : matplotlib.axes.Axes or None, optional\n        Matplotlib axes object for plotting. If None, creates a new plot, by default None.\n    color : str, optional\n        Color for the plot lines, by default \"blue\".\n    alpha : float, optional\n        Transparency level for individual lines (0.0 to 1.0), by default 0.5.\n        Lower values help visualize overlapping time series.\n\n    Returns\n    -------\n    None\n        The function creates a plot but doesn't return any value.\n\n    Notes\n    -----\n    This function normalizes timestamps to year fractions, where each time series\n    starts from 0.0, making it possible to overlay multiple years of data for\n    pattern analysis. The original timestamps are converted using the `year_fraction`\n    function and then normalized to start from zero.\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    long_sits = download_multiple_sits(gdf, satellite, reducers=[reducer])\n\n    if len(long_sits) == 0:\n        return None\n\n    for indexnumm in long_sits.indexnum.unique():\n        indexnumm_df = long_sits[long_sits.indexnum == indexnumm].reset_index(drop=True).copy()\n        indexnumm_df[\"timestamp\"] = indexnumm_df.timestamp.apply(year_fraction)\n        indexnumm_df[\"timestamp\"] = indexnumm_df[\"timestamp\"] - indexnumm_df[\"timestamp\"].min().round()\n\n        y = indexnumm_df[band_or_indice_to_plot].values\n\n        if ax is None:\n            plt.plot(\n                indexnumm_df.timestamp,\n                y,\n                color=color,\n                alpha=alpha,\n            )\n        else:\n            ax.plot(indexnumm_df.timestamp, y, color=color, alpha=alpha, label=satellite.shortName)\n</code></pre>"}]}